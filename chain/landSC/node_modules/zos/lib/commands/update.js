'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _update = require('../scripts/update');

var _update2 = _interopRequireDefault(_update);

var _runWithTruffle = require('../utils/runWithTruffle');

var _runWithTruffle2 = _interopRequireDefault(_runWithTruffle);

var _input = require('../utils/input');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const name = 'update';
const signature = `${name} [alias] [address]`;
const description = 'update contract to a new logic. Provide the [alias] you added your contract with, or use --all flag to update all. If no [address] is provided, all instances of that contract class will be updated';

const register = program => program.command(signature, { noHelp: true }).usage('[alias] [address] --network <network> [options]').description(description).option('--init [function]', `call function after upgrading contract. If no name is given, 'initialize' will be used`).option('--args <arg1, arg2, ...>', 'provide initialization arguments for your contract if required').option('--all', 'update all contracts in the application').option('--force', 'force creation even if contracts have local modifications').withNetworkOptions().action(action);

async function action(contractAlias, proxyAddress, options) {
  const { initMethod, initArgs } = (0, _input.parseInit)(options, 'initialize');
  const { all, force } = options;
  await (0, _runWithTruffle2.default)(async opts => await (0, _update2.default)(_extends({
    contractAlias, proxyAddress, initMethod, initArgs, all, force }, opts)), options);
}

exports.default = { name, signature, description, register, action };