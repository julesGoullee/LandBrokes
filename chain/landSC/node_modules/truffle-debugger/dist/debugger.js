(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.isCallMnemonic = isCallMnemonic;
exports.isCreateMnemonic = isCreateMnemonic;

var _truffleDecodeUtils = __webpack_require__(7);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const stringify = __webpack_require__(42);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256({ type: "string", value: stringify(obj) });
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a creation
 * instruction
 */
function isCreateMnemonic(op) {
  const creates = ["CREATE", "CREATE2"];
  return creates.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _truffleSolidityUtils = __webpack_require__(46);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(47);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _map = __webpack_require__(24);

var _jsonPointer = __webpack_require__(21);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

const semver = __webpack_require__(51);

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sourceMaps.byContext)
  },

  /**
   * solidity.current
   */
  current: {
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], ({ context }, sourceMaps) => sourceMaps[context] || {}),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: state => state.solidity.proc.functionDepth,

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, { sourceMap }) => {
      if (!binary) {
        return [];
      }

      let instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      let lastSeen = null;
      for (let [pc, instruction] of map.entries()) {
        if (instruction) {
          lastSeen = instruction;
        } else {
          map[pc] = lastSeen;
        }
      }
      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], (map, pc) => map[pc] || {}),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompile
     */
    callsPrecompile: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompile], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    //HACK: DUPLICATE CODE FOLLOWS
    //The following code duplicates some selectors in ast.
    //This exists to suppor the solidity.current.contractCall workaround below.
    //This should be cleaned up later.

    /**
     * solidity.current.pointer
     * HACK duplicates ast.current.pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * solidity.current.node
     * HACK duplicates ast.current.node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "")),

    /**
     * solidity.current.isContractCall
     * HACK WORKAROUND (only applies to solc version <0.5.1)
     * this selector exists to work around a problem in solc
     * it attempts to detect whether the current node is a contract method call
     * (or library method call)
     * it will not successfully detect this if the method was first placed in a
     * function variable, only if it is being called directly
     */
    isContractCall: (0, _reselectTree.createLeaf)(["./node"], node => node !== undefined && node.nodeType === "FunctionCall" && node.expression !== undefined && node.expression.nodeType === "MemberAccess" && node.expression.expression !== undefined && (DecodeUtils.Definition.isContract(node.expression.expression) || DecodeUtils.Definition.isContractType(node.expression.expression))),

    /**
     * solidity.current.needsFunctionDepthWorkaround
     * HACK
     * Determines if the solidity version used for the contract about to be
     * called was <0.5.1, to determine whether to use the above workaround
     * Only call this if the current step is a call or create!
     */
    needsFunctionDepthWorkaround: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callContext], context => context.compiler !== undefined && //would be undefined for e.g. a precompile
    context.compiler.name === "solc" && semver.satisfies(context.compiler.version, "<0.5.1"))
  }
});

exports.default = solidity;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _fastLevenshtein = __webpack_require__(50);

var _fastLevenshtein2 = _interopRequireDefault(_fastLevenshtein);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

function findContext({ address, binary }, instances, search, contexts) {
  let record;
  if (address) {
    record = instances[address];
    if (!record) {
      return { address };
    }
    binary = record.binary;
  } else {
    record = search(binary);
  }

  let context = contexts[(record || {}).context];

  return (0, _extends3.default)({}, context, {
    binary
  });
}

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCreateMnemonic)(step.op)),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "STOP" || step.op == "RETURN")
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], (matches, step, { stack }) => {
        if (!matches) return null;

        let address = stack[stack.length - 2];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], (matches, step, { stack, memory }) => {
        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callContext
       *
       * context for what we're about to call into (or create)
       */
      callContext: (0, _reselectTree.createLeaf)(["./callAddress", "./createBinary", "/info/instances", "/info/binaries/search", "/info/contexts"], (address, binary, instances, search, contexts) => findContext({ address, binary }, instances, search, contexts)),

      /**
       * .callsPrecompile
       *
       * is the call address to a precompiled contract?
       * HACK
       */
      callsPrecompile: (0, _reselectTree.createLeaf)(["./callAddress", "/info/contexts", "/info/instances"], (address, contexts, instances) => {
        if (!address) return null;

        let { context } = instances[address] || {};
        let { binary } = contexts[context] || {};
        return !binary;
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(["/state"], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byBinary),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(["./_"], binaries => binary => {
        // search for a given binary based on levenshtein distances to
        // existing (known) context binaries.
        //
        // levenshtein distance is the number of textual modifications
        // (insert, change, delete) required to convert string a to b
        //
        // filter by a percentage threshold
        const threshold = 0.25;

        // skip levenshtein check for undefined binaries
        if (!binary || binary == "0x0") {
          return {};
        }

        const results = (0, _entries2.default)(binaries).map(([knownBinary, { context }]) => ({
          context,
          distance: _fastLevenshtein2.default.get(knownBinary, binary)
        })).filter(({ distance }) => distance <= binary.length * threshold).sort(({ distance: a }, { distance: b }) => a - b);

        if (results[0]) {
          const { context } = results[0];
          return { context };
        }

        return {};
      })
    }
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.creationDepth
     * how many creation calls are currently on the call stack?
     */
    creationDepth: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.filter(call => call.address === undefined).length),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], findContext),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash,
    provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(21);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ ast }) => ast),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ id }) => id),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], (ast, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], (ast, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))

  }
});

exports.default = ast;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(2);

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.finished
   *
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return the *same* trace step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : steps[index])
});

exports.default = trace;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

exports.scope = scope;
exports.declare = declare;
exports.defineType = defineType;
exports.reset = reset;
exports.learnAddressSaga = learnAddressSaga;
exports.recordAllocations = recordAllocations;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(26);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(20);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(25);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas"); // eslint-disable-line no-unused-vars

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.putResolve)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.putResolve)(actions.declare(node));
}

function* defineType(node) {
  yield (0, _effects.putResolve)(actions.defineType(node));
}

function* tickSaga() {
  let node = (yield (0, _effects.select)(_selectors2.default.views.ast)).node;
  let decode = yield (0, _effects.select)(_selectors2.default.views.decoder);
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations.storage);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address); //may be undefined
  let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.dummyAddress);

  debug("node %o", node);

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var assignment, assignments;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
      let parameters = node.parameters.parameters;
      //note that we do *not* include return parameters, since those are
      //handled by the VariableDeclaration case (no, I don't know why it
      //works out that way)
      let reverseParameters = parameters.slice().reverse();
      //reverse is in-place, so we use slice() to clone first
      debug("reverseParameters %o", parameters);

      let currentPosition = top;
      assignments = { byId: {} };

      for (let parameter of reverseParameters) {
        let words = DecodeUtils.Definition.stackSize(parameter);
        let pointer = {
          stack: {
            from: currentPosition - words + 1,
            to: currentPosition
          }
        };
        let assignment = makeAssignment({ astId: parameter.id, stackframe: currentDepth }, pointer);
        assignments.byId[assignment.id] = assignment;
        currentPosition -= words;
      }

      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "ContractDefinition":
      let allocation = allocations[node.id];

      debug("Contract definition case");
      debug("allocations %O", allocations);
      debug("allocation %O", allocation);
      assignments = { byId: {} };
      for (let id in allocation.members) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj;
        if (address !== undefined) {
          idObj = { astId: id, address };
        } else {
          idObj = { astId: id, dummyAddress };
        }
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, allocation.members[id].pointer)
        });
        assignments.byId[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "VariableDeclaration":
      let varId = node.id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined || currentAssignments.byId[id].dummyAddress !== undefined)) {
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = makeAssignment({ astId: varId, stackframe: currentDepth }, {
        stack: {
          from: top - DecodeUtils.Definition.stackSize(node) + 1,
          to: top
        }
      });
      assignments = { byId: { [assignment.id]: assignment } };
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indices

      debug("Index access case");

      let baseExpression = node.baseExpression;
      let baseDeclarationId = baseExpression.referencedDeclaration;

      let baseDeclaration = scopes[baseDeclarationId].definition;

      //if we're not dealing with a mapping, don't bother!
      if (!DecodeUtils.Definition.isMapping(baseExpression)) {
        break;
      }

      let keyDefinition = baseDeclaration.keyType || baseDeclaration.typeName.keyType;

      //begin subsection: key decoding
      //(I tried factoring this out into its own saga but it didn't work when I
      //did :P )
      yield (0, _effects.put)(actions.mapKeyDecoding(true));

      let indexValue;
      let indexDefinition = node.indexExpression;

      //why the loop? see the end of the block it heads to for an explanatory
      //comment
      while (indexValue === undefined) {
        let indexId = indexDefinition.id;
        //indices need to be identified by stackframe
        let indexIdObj = { astId: indexId, stackframe: currentDepth };
        let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

        const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;

        if (DecodeUtils.Definition.isSimpleConstant(indexDefinition)) {
          //while the main case is the next one, where we look for a prior
          //assignment, we need this case (and need it first) for two reasons:
          //1. some constant expressions (specifically, string and hex literals)
          //aren't sourcemapped to and so won't have a prior assignment
          //2. if the key type is bytesN but the expression is constant, the
          //value will go on the stack *left*-padded instead of right-padded,
          //so looking for a prior assignment will read the wrong value.
          //so instead it's preferable to use the constant directly.
          indexValue = yield (0, _effects.call)(decode, keyDefinition, {
            definition: indexDefinition
          });
        } else if (indexReference) {
          //if a prior assignment is found
          let splicedDefinition;
          //in general, we want to decode using the key definition, not the index
          //definition. however, the key definition may have the wrong location
          //on it.  so, when applicable, we splice the index definition location
          //onto the key definition location.
          if (DecodeUtils.Definition.isReference(indexDefinition)) {
            splicedDefinition = DecodeUtils.Definition.spliceLocation(keyDefinition, DecodeUtils.Definition.referenceType(indexDefinition));
          } else {
            splicedDefinition = keyDefinition;
          }
          indexValue = yield (0, _effects.call)(decode, splicedDefinition, indexReference);
        } else if (indexDefinition.referencedDeclaration && scopes[indexDefinition.referenceDeclaration]) {
          //there's one more reason we might have failed to decode it: it might be a
          //constant state variable.  Unfortunately, we don't know how to decode all
          //those at the moment, but we can handle the ones we do know how to decode.
          //In the future hopefully we will decode all of them
          debug("referencedDeclaration %d", indexDefinition.referencedDeclaration);
          let indexConstantDeclaration = scopes[indexDefinition.referencedDeclaration].definition;
          debug("indexConstantDeclaration %O", indexConstantDeclaration);
          if (indexConstantDeclaration.constant) {
            let indexConstantDefinition = indexConstantDeclaration.value;
            //next line filters out constants we don't know how to handle
            if (DecodeUtils.Definition.isSimpleConstant(indexConstantDefinition)) {
              indexValue = yield (0, _effects.call)(decode, keyDefinition, {
                definition: indexConstantDeclaration.value
              });
            }
          }
        }
        //there's still one more reason we might have failed to decode it:
        //certain (silent) type conversions aren't sourcemapped either.
        //(thankfully, any type conversion that actually *does* something seems
        //to be sourcemapped.)  So if we've failed to decode it, we try again
        //with the argument of the type conversion, if it is one; we leave
        //indexValue undefined so the loop will continue
        //(note that this case is last for a reason; if this were earlier, it
        //would catch *non*-silent type conversions, which we want to just read
        //off the stack)
        else if (indexDefinition.kind === "typeConversion") {
            indexDefinition = indexDefinition.arguments[0];
          }
          //otherwise, we've just totally failed to decode it, so we mark
          //indexValue as null (as distinct from undefined) to indicate this.  In
          //the future, we should be able to decode all mapping keys, but we're
          //not quite there yet, sorry (because we can't yet handle all constant
          //state variables)
          else {
              indexValue = null;
            }
        //now, as mentioned, retry in the typeConversion case
      }

      yield (0, _effects.put)(actions.mapKeyDecoding(false));
      //end subsection: key decoding

      debug("index value %O", indexValue);
      debug("keyDefinition %O", keyDefinition);

      //if we succeeded at decoding it -- i.e. it's not null -- then map it!
      if (indexValue !== null) {
        yield (0, _effects.put)(actions.mapKey(baseDeclarationId, indexValue));
      }

      break;

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      let literal = (0, _truffleDecoder.readStack)(stack, top - DecodeUtils.Definition.stackSize(node) + 1, top);

      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);
      assignment = makeAssignment({ astId: node.id, stackframe: currentDepth }, { literal });
      assignments = { byId: { [assignment.id]: assignment } };
      yield (0, _effects.put)(actions.assign(assignments));
      break;
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* learnAddressSaga(dummyAddress, address) {
  debug("about to learn an address");
  yield (0, _effects.put)(actions.learnAddress(dummyAddress, address));
  debug("address learnt");
}

function* recordAllocations() {
  let contracts = yield (0, _effects.select)(_selectors2.default.views.userDefinedTypes.contractDefinitions);
  debug("contracts %O", contracts);
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  debug("referenceDeclarations %O", referenceDeclarations);
  let storageAllocations = (0, _truffleDecoder.getStorageAllocations)(referenceDeclarations, contracts);
  debug("storageAllocations %O", storageAllocations);
  yield (0, _effects.put)(actions.allocate(storageAllocations));
}

function makeAssignment(idObj, ref) {
  let id = (0, _helpers.stableKeccak256)(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, function* () {
    try {
      yield* tickSaga();
    } catch (e) {
      debug("ERROR: %O", e);
    }
  });
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginStep = beginStep;
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
const BEGIN_STEP = exports.BEGIN_STEP = "BEGIN_STEP";
function beginStep(type) {
  return {
    type: BEGIN_STEP,
    stepType: type
  };
}

const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance() {
  return { type: ADVANCE };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint() {
  //"continue" is not a legal name
  return { type: CONTINUE };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(18);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(21);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(14);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(9);

var _selectors6 = _interopRequireDefault(_selectors5);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(25);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors"); // eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

function createStateSelectors({ stack, memory, storage }) {
  return {
    /**
     * .stack
     */
    stack: (0, _reselectTree.createLeaf)([stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word))),

    /**
     * .memory
     */
    memory: (0, _reselectTree.createLeaf)([memory], words => DecodeUtils.Conversion.toBytes(words.join(""))),

    /**
     * .storage
     */
    storage: (0, _reselectTree.createLeaf)([storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
      [`0x${address}`]: DecodeUtils.Conversion.toBytes(word)
    }))))
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    /**
     * data.views.ast
     */
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], tree => tree),

    /*
     * data.views.atLastInstructionForSourceRange
     */
    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes (namespace)
     */
    scopes: {
      /**
       * data.views.scopes.inlined (namespace)
       */
      inlined: {
        /**
         * data.views.scopes.inlined (selector)
         * see data.info.scopes for how this differs from the raw version
         */
        _: (0, _reselectTree.createLeaf)(["/info/scopes", "./raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(inlined).map(([id, info]) => {
          let newInfo = (0, _extends3.default)({}, info);
          newInfo.variables = scopes[id].variables;
          return { [id]: newInfo };
        }))),

        /**
         * data.views.scopes.inlined.raw
         */
        raw: (0, _reselectTree.createLeaf)(["/info/scopes/raw", _selectors6.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
          [id]: (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          })
        }))))
      }
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => Promise<value>
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/referenceDeclarations", "/next/state", "/proc/mappingKeys", "/info/allocations/storage"], (referenceDeclarations, state, mappingKeys, storageAllocations) => (definition, ref) => (0, _truffleDecoder.forEvmState)(definition, ref, {
      referenceDeclarations,
      state,
      mappingKeys,
      storageAllocations
    })),

    /*
     * data.views.userDefinedTypes
     */
    userDefinedTypes: {
      /*
       * data.views.userDefinedTypes.contractDefinitions
       * restrict to contracts only, and get their definitions
       */
      contractDefinitions: (0, _reselectTree.createLeaf)(["/info/userDefinedTypes", "/views/scopes/inlined"], (typeIds, scopes) => typeIds.map(id => scopes[id].definition).filter(node => node.nodeType === "ContractDefinition"))
    },

    /*
     * data.views.referenceDeclarations
     */
    referenceDeclarations: (0, _reselectTree.createLeaf)(["./scopes/inlined", "/info/userDefinedTypes"], (scopes, userDefinedTypes) => (0, _assign2.default)({}, ...userDefinedTypes.map(id => ({ [id]: scopes[id].definition }))))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes (namespace)
     */
    scopes: {
      /**
       * data.info.scopes (selector)
       * the raw version is below; this version accounts for inheritance
       * NOTE: doesn't this selector really belong in data.views?  Yes.
       * But, since it's replacing the old data.info.scopes (which is now
       * data.info.scopes.raw), I didn't want to move it.
       */
      _: (0, _reselectTree.createLeaf)(["./raw", "/views/scopes/inlined/raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, scope]) => {
        let definition = inlined[id].definition;
        if (definition.nodeType !== "ContractDefinition" || scope.variables === undefined) {
          return { [id]: scope };
        }
        //if we've reached this point, we should be dealing with a
        //contract, and specifically a contract -- not an interface or
        //library (those don't get "variables" entries in their scopes)
        debug("contract id %d", id);
        let newScope = (0, _extends3.default)({}, scope);
        //note that Solidity gives us the linearization in order from most
        //derived to most base, but we want most base to most derived;
        //annoyingly, reverse() is in-place, so we clone with slice() first
        let linearizedBaseContractsFromBase = definition.linearizedBaseContracts.slice().reverse();
        //now, we put it all together
        newScope.variables = [].concat(...linearizedBaseContractsFromBase.map(contractId => scopes[contractId].variables)).filter(variable => {
          //...except, HACK, let's filter out those constants we don't know
          //how to read.  they'll just clutter things up.
          let definition = inlined[variable.id].definition;
          return !definition.constant || DecodeUtils.Definition.isSimpleConstant(definition.value);
        });

        return { [id]: newScope };
      }))),

      /*
       * data.info.scopes.raw
       */
      raw: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
    },

    /*
     * data.info.allocations
     */
    allocations: {
      /*
       * data.info.allocations.storage
       */
      storage: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.storage)
    },

    /**
     * data.info.userDefinedTypes
     */
    userDefinedTypes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.userDefinedTypes)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /**
     * data.proc.mappingKeys
     *
     * known keys for each mapping (identified by node ID)
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappingKeys.byId),

    /**
     * data.proc.decodingMappingKeys
     *
     * number of mapping keys that are still decoding
     */
    decodingMappingKeys: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappingKeys.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     *
     * data.current.scope
     */
    scope: {
      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], node => node.id)
    },

    /**
     * data.current.state
     */
    state: createStateSelectors(_selectors4.default.current.state),

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors6.default.current.functionDepth], identity),

    /**
     * data.current.address
     * Note: May be undefined (if in an initializer)
     */

    address: (0, _reselectTree.createLeaf)([_selectors4.default.current.call], call => call.address),

    /**
     * data.current.dummyAddress
     */

    dummyAddress: (0, _reselectTree.createLeaf)([_selectors4.default.current.creationDepth], identity),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], (scopes, scope) => {
        let cur = scope.id;
        let variables = {};

        do {
          variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
          .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: v.id })));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], (scopes, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { definition } = scopes[id];

        return { [identifier]: definition };
      }))),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", _selectors6.default.current.functionDepth, //for pruning things too deep on stack
      "/current/address", //for contract variables
      "/current/dummyAddress" //for contract vars when in creation call
      ], (assignments, identifiers, currentDepth, address, dummyAddress) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, astId]) => {
        //note: this needs tweaking for specials later
        let id;

        //first, check if it's a contract var
        if (address !== undefined) {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }
        } else {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].dummyAddress === dummyAddress);
          if (matchIds.length > 0) {
            id = matchIds[0]; //again, there should only be one!
          }
        }

        //if not contract, it's local, so find the innermost
        //(but not beyond current depth)
        if (id === undefined) {
          let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

          if (matchFrames.length > 0) {
            //this check isn't *really*
            //necessary, but may as well prevent stupid stuff
            let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
            id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
          }
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      }))),

      /**
       * data.current.identifiers.decoded
       *
       * Returns an object with values as Promises
       */
      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (() => {
        var _ref = (0, _asyncToGenerator3.default)(function* (decode, definitions, refs) {
          const keyedPromises = (0, _entries2.default)(refs).map((() => {
            var _ref2 = (0, _asyncToGenerator3.default)(function* ([identifier, ref]) {
              return {
                [identifier]: yield decode(definitions[identifier], ref)
              };
            });

            return function (_x4) {
              return _ref2.apply(this, arguments);
            };
          })());
          const keyedResults = yield _promise2.default.all(keyedPromises);
          return DecodeUtils.Conversion.cleanContainers((0, _assign2.default)({}, ...keyedResults));
        });

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      })())
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     */
    state: createStateSelectors(_selectors4.default.next.state)
  }
});

exports.default = data;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(48);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  let overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapKey = mapKey;
exports.mapKeyDecoding = mapKeyDecoding;
exports.reset = reset;
exports.learnAddress = learnAddress;
exports.defineType = defineType;
exports.allocate = allocate;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(assignments) {
  return {
    type: ASSIGN,
    assignments
  };
}

const MAP_KEY = exports.MAP_KEY = "MAP_KEY";
function mapKey(id, key) {
  return {
    type: MAP_KEY,
    id,
    key
  };
}

const MAP_KEY_DECODING = exports.MAP_KEY_DECODING = "MAP_KEY_DECODING";
function mapKeyDecoding(started) {
  return {
    type: MAP_KEY_DECODING,
    started
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const LEARN_ADDRESS = exports.LEARN_ADDRESS = "LEARN_ADDRESS";
function learnAddress(dummyAddress, address) {
  return {
    type: LEARN_ADDRESS,
    dummyAddress,
    address
  };
}

const DEFINE_TYPE = exports.DEFINE_TYPE = "DEFINE_TYPE";
function defineType(node) {
  return {
    type: DEFINE_TYPE,
    node
  };
}

const ALLOCATE = exports.ALLOCATE = "ALLOCATE";
function allocate(storage) {
  return {
    type: ALLOCATE,
    storage
    //later there will be more
  };
}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(17);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.processTrace = processTrace;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.filter(({ op }) => (0, _helpers.isCallMnemonic)(op)).map(({ stack }) => DecodeUtils.Conversion.toAddress(stack[stack.length - 2])))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(16);

var data = _interopRequireWildcard(_sagas);

var _truffleDecodeUtils = __webpack_require__(7);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(contractName, { address, binary }, compiler) {
  const raw = binary || address;
  const context = (0, _helpers.keccak256)(raw);

  yield (0, _effects.put)(actions.addContext(contractName, raw, compiler));

  if (binary) {
    yield (0, _effects.put)(actions.addBinary(context, binary));
  }

  return context;
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let { context } = search(binary);

  // in case binary is unknown, add context for address
  if (!context) {
    context = yield* addContext(undefined, { address }, undefined);
  }

  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({ address, binary }) {
  if (address) {
    yield (0, _effects.put)(actions.call(address));
  } else {
    yield (0, _effects.put)(actions.create(binary));
  }
}

function* callstackSaga() {
  while (true) {
    yield (0, _effects.take)(_actions.TICK);

    if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
      debug("got call");
      let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);

      debug("calling address %s", address);

      // if there is no binary (e.g. in the case of precompiled contracts),
      // then there will be no trace steps for the called code, and so we
      // shouldn't tell the debugger that we're entering another execution
      // context
      if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompile)) {
        continue;
      }

      yield (0, _effects.put)(actions.call(address));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
      debug("got create");
      let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);

      yield (0, _effects.put)(actions.create(binary));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
      debug("got return");

      let callstack = yield (0, _effects.select)(_selectors2.default.current.callstack);

      //if the program's not ending, and we just returned from a constructor,
      //learn the address of what we just initialized
      //(do this before we put the return action to avoid off-by-one error)
      if (callstack.length > 1 && callstack[callstack.length - 1].address === undefined) {
        let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.creationDepth);
        debug("dummyAddress %d", dummyAddress);

        //NOTE: the following logic, for getting the created address, really
        //belongs in a selector.  However, every time I try to make it a
        //selector, I get mysterious error messages.  So, we'll do it ourselves
        //in the saga instead.

        let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
        let createdAddress = DecodeUtils.Conversion.toAddress(stack[stack.length - 1]);
        debug("createdAddress %s", createdAddress);

        yield* data.learnAddressSaga(dummyAddress, createdAddress);
        debug("address learnt");
      }

      yield (0, _effects.put)(actions.returnCall());
    }
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.call)(callstackSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addBinary = addBinary;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.reset = reset;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, raw, compiler) {
  return {
    type: ADD_CONTEXT,
    contractName,
    raw,
    compiler
  };
}

const ADD_BINARY = exports.ADD_BINARY = "EVM_ADD_BINARY";
function addBinary(context, binary) {
  return {
    type: ADD_BINARY,
    context,
    binary
  };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const CALL = exports.CALL = "CALL";
function call(address) {
  return {
    type: CALL,
    address
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(11);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast));
}

function* addSourceMap(binary, sourceMap) {
  yield (0, _effects.put)(actions.addSourceMap(binary, sourceMap));
}

function* tickSaga() {
  while (true) {
    yield (0, _effects.take)(_actions2.TICK);
    debug("got TICK");

    yield* functionDepthSaga();
  }
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    //we have several cases here:
    //1. precompile -- *don't* put any jump
    //2. workaround case -- put a double jump (see below)
    //3. general case -- put a single jump as expected

    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompile)) {
      //call to precompile; do nothing
    } else if ((yield (0, _effects.select)(_selectors2.default.current.needsFunctionDepthWorkaround)) && (yield (0, _effects.select)(_selectors2.default.current.isContractCall))) {
      //all these parentheses are necessary
      //HACK WORKAROUND
      //because of the problem in solc <0.5.1 where contract method calls
      //essentially return twice, we compensate by putting *two* inward jumps
      //for such a call.
      //Note that this won't work if the contract method was previously placed
      //in a function variable!  Those will continue to screw things up!  But
      //if a contract call is being made directly, we can detect that.
      //Of course, all of this should work fine as of solidity 0.5.1, with no
      //workaround necessary; this branch should only get take on old
      //contracts.
      debug("workaround invoked!");
      yield (0, _effects.put)(actions.jump("2"));
    } else {
      //an ordinary call, not to a precompile & with no workaround needed
      yield (0, _effects.put)(actions.jump("i"));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    //this case, thankfully, needs no further breakdown
    yield (0, _effects.put)(actions.jump("i"));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.jump("o"));
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.call)(tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast
  };
}

const ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary,
    sourceMap
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(14);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(15);

var _selectors8 = _interopRequireDefault(_selectors7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({

  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  },

  /**
   * controller.breakpoints
   */
  breakpoints: (0, _reselectTree.createLeaf)(["./state"], state => state.breakpoints),

  /**
   * controller.finished
   */
  finished: (0, _reselectTree.createLeaf)([_selectors8.default.finished], identity)

});

exports.default = controller;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(34).default;

module.exports = Debugger;



/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(35);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(36);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(20);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(14);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(15);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(10);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(9);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(66);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(32);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _values = __webpack_require__(23);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(18);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(37);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(19);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(20);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(52);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(59);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session"); //eslint-disable-line no-unused-vars

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    return new _promise2.default((accept, reject) => {
      this._store.subscribe(() => {
        if (this.state.session.status == "ACTIVE") {
          accept();
        } else if (typeof this.state.session.status == "object") {
          reject(this.state.session.status.error);
        }
      });
    });
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        compiler
      } = contract;

      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);

      sourcesByPath[sourcePath] = { sourcePath, source, ast };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          compiler
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    this._store.dispatch(action);

    return true;
  }

  interrupt() {
    return this.dispatch(controller.interrupt());
  }

  advance() {
    return this.dispatch(controller.advance());
  }

  stepNext() {
    return this.dispatch(controller.stepNext());
  }

  stepOver() {
    return this.dispatch(controller.stepOver());
  }

  stepInto() {
    return this.dispatch(controller.stepInto());
  }

  stepOut() {
    return this.dispatch(controller.stepOut());
  }

  reset() {
    return this.dispatch(controller.reset());
  }

  continueUntilBreakpoint() {
    return this.dispatch(controller.continueUntilBreakpoint());
  }

  addBreakpoint(breakpoint) {
    return this.dispatch(controller.addBreakpoint(breakpoint));
  }

  removeBreakpoint(breakpoint) {
    return this.dispatch(controller.removeBreakpoint(breakpoint));
  }

  removeAllBreakpoints() {
    return this.dispatch(controller.removeAllBreakpoints());
  }

  decodeReady() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let haveResolved = false;
        const unsubscribe = _this._store.subscribe(function () {
          const subscriptionDecodingStarted = _this.view(_selectors2.default.proc.decodingMappingKeys);

          debug("following decoding started: %d", subscriptionDecodingStarted);

          if (subscriptionDecodingStarted <= 0 && !haveResolved) {
            haveResolved = true;
            unsubscribe();
            resolve();
          }
        });

        const decodingStarted = _this.view(_selectors2.default.proc.decodingMappingKeys);

        debug("initial decoding started: %d", decodingStarted);

        if (decodingStarted <= 0) {
          haveResolved = true;
          unsubscribe();
          resolve();
        }
      });
    })();
  }

  variable(name) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this2.decodeReady();

      const definitions = _this2.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this2.view(_selectors2.default.current.identifiers.refs);

      const decode = _this2.view(_selectors2.default.views.decoder);
      return yield decode(definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this3.decodeReady();

      return yield _this3.view(_selectors2.default.current.identifiers.decoded);
    })();
  }
}
exports.default = Session;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(38);
} else if (process.env.NODE_ENV === "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(39);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(5);

var _reduxSaga = __webpack_require__(40);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(41);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(43);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(44);
exports.stringify = __webpack_require__(45);


/***/ }),
/* 44 */
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(49);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("fast-levenshtein");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = options.loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  if (version instanceof SemVer) {
    if (version.loose === options.loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, options);

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.options, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, options);

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.options.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function(comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range))
    return new Range(range, options);

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.options.loose;
  range = range.trim();
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, this.options);
  }, this);

  return set;
};

Range.prototype.intersects = function(range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, options) {
  return new Range(range, options).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, options) {
  debug('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options))
      return true;
  }
  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (!options)
    options = {}

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, options) {
  return outside(version, range, '<', options);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;
function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, options) {
  var parsed = parse(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(53);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(54);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(30);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(28);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(27);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(16);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(55);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  } else {
    debug("visiting ASTs");
    // visit asts
    yield* ast.visitAll();

    //save allocation table
    debug("saving allocation table");
    yield* data.recordAllocations();

    debug("readying");
    // signal that stepping can begin
    yield* ready();
  }
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  return yield (0, _effects.all)([controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)
  //ast no longer has a listener
  ));
}

function* fetchTx(txHash, provider) {
  let result = yield* web3.inspectTransaction(txHash, provider);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  let addresses = yield* trace.processTrace(result.trace);
  if (result.address && addresses.indexOf(result.address) == -1) {
    addresses.push(result.address);
  }

  let binaries = yield* web3.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let _ref of contexts) {
    let { contractName, binary, sourceMap, compiler } = _ref;

    yield* evm.addContext(contractName, { binary }, compiler);

    if (sourceMap) {
      yield* solidity.addSourceMap(binary, sourceMap);
    }
  }
}

function* recordSources(...sources) {
  for (let i = 0; i < sources.length; i++) {
    const sourceData = sources[i];
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _sagas = __webpack_require__(16);

var data = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(14);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
    case "ContractDefinition":
    case "StructDefinition":
    case "EnumDefinition":
      yield* data.defineType(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* visitAll() {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  yield (0, _effects.all)((0, _entries2.default)(sources).filter(([_, source]) => source.ast).map(([id, { ast }]) => (0, _effects.call)(walk, id, ast)));

  debug("done visiting");
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(17);

var _set2 = _interopRequireDefault(_set);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(27);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(16);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(28);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(30);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(19);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(32);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint,
  [actions.RESET]: reset
};

/** AST node types that are skipped to filter out some noise */
const SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.put)(actions.beginStep(action.type));

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action),
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/**
 * Advance the state by one instruction
 */

function* advance() {
  // send action to advance trace
  yield* trace.advance();
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();

    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint() {
  var currentLocation, currentNode, currentLine, currentSourceId;
  var finished;
  var previousLine, previousSourceId;

  let breakpoints = yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  currentNode = currentLocation.node.id;
  currentLine = currentLocation.sourceRange.lines.start.line;
  currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    previousLine = currentLine;
    previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    finished = yield (0, _effects.select)(_selectors2.default.finished);
    debug("finished %o", finished);

    currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;
    currentSourceId = currentLocation.source.id;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        debug("node %d currentNode %d", node, currentNode);
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit && !finished);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(56);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(13);

var session = _interopRequireWildcard(_actions2);

var _adapter = __webpack_require__(57);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas");

function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));

  if (tx.to && tx.to != "0x0") {
    yield (0, _effects.put)(actions.receiveCall({ address: tx.to }));
    return;
  }

  if (receipt.contractAddress) {
    yield (0, _effects.put)(actions.receiveCall({ binary: tx.input }));
    return;
  }

  throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)(({ type }) => type == actions.RECEIVE_TRACE || type == actions.ERROR_WEB3);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let { address, binary } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return { trace, address, binary };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({ address, binary }) {
  return {
    type: RECEIVE_CALL,
    address,
    binary
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(18);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(58);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this.web3.currentProvider.send({
          jsonrpc: "2.0",
          method: "debug_traceTransaction",
          params: [txHash, {}],
          id: new Date().getTime()
        }, function (err, result) {
          if (err) return reject(err);
          if (result.error) return reject(new Error(result.error.message));
          debug("result: %o", result);
          accept(result.result.structLogs);
        });
      });
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this2.web3.eth.getTransaction(txHash, function (err, tx) {
          if (err) return reject(err);

          return accept(tx);
        });
      });
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this3.web3.eth.getTransactionReceipt(txHash, function (err, receipt) {
          if (err) return reject(err);

          return accept(receipt);
        });
      });
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      return new _promise2.default(function (accept, reject) {
        _this4.web3.eth.getCode(address, function (err, deployedBinary) {
          if (err) debug("error: %o", err);
          if (err) return reject(err);
          debug("got deployed code for %s", address);
          accept(deployedBinary);
        });
      });
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.status = status;
exports.transaction = transaction;
exports.receipt = receipt;

var _redux = __webpack_require__(5);

var _reducers = __webpack_require__(60);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(61);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(63);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(64);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(65);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";

function status(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  status,
  transaction,
  receipt
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _set = __webpack_require__(17);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(23);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(26);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

//a note on the following reducer: solidity assigns a unique AST ID to every
//AST node among all the files being compiled together.  thus, it is, for now,
//safe to identify user-defined types solely by their AST ID.  In the future,
//once we eventually support having some files compiled separately from others,
//this will become a bug you'll have to fix, and you'll have to fix it in the
//decoder, too.  Sorry, future me! (or whoever's stuck doing this)

function userDefinedTypes(state = [], action) {
  switch (action.type) {
    case actions.DEFINE_TYPE:
      return [...state, action.node.id];
    default:
      return state;
  }
}

function storage(state = {}, action) {
  if (action.type === actions.ALLOCATE) {
    return action.storage;
  } else {
    return state;
  }
}

const allocations = (0, _redux.combineReducers)({
  storage
});

const info = (0, _redux.combineReducers)({
  scopes,
  userDefinedTypes,
  allocations
});

const DEFAULT_ASSIGNMENTS = {
  byId: {},
  byAstId: {}
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments.byId).reduce((acc, assignment) => {
        let { id, astId } = assignment; //we don't need the rest
        return {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        };
      }, state);

    case actions.LEARN_ADDRESS:
      let { dummyAddress, address } = action;
      return {
        byId: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byId).map(([, assignment]) => {
          let newAssignment = learnAddress(assignment, dummyAddress, address);
          return {
            [newAssignment.id]: newAssignment
          };
        })),
        byAstId: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byAstId).map(([astId]) => {
          return {
            [astId]: state.byAstId[astId].map(id => learnAddress(state.byId[id], dummyAddress, address).id
            //this above involves some recomputation but oh well
            )
          };
        }))
      };

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

function learnAddress(assignment, dummyAddress, address) {
  if (assignment.dummyAddress === dummyAddress) {
    //we can assume here that the object being
    //transformed has a very particular form
    let newIdObj = {
      astId: assignment.astId,
      address
    };
    let newId = (0, _helpers.stableKeccak256)(newIdObj);
    return {
      id: newId,
      ref: assignment.ref,
      astId: assignment.astId,
      address
    };
  } else {
    return assignment;
  }
}

const DEFAULT_MAPPING_KEYS = {
  decodingStarted: 0,
  byId: {}
};

function mappingKeys(state = DEFAULT_MAPPING_KEYS, action) {
  switch (action.type) {
    case actions.MAP_KEY_DECODING:
      debug("decoding started: %d", state.decodingStarted + (action.started ? 1 : -1));
      return {
        decodingStarted: state.decodingStarted + (action.started ? 1 : -1),
        byId: (0, _extends3.default)({}, state.byId)
      };
    case actions.MAP_KEY:
      let { id, key } = action;
      debug("mapping id and key: %s, %o", id, key);

      return {
        decodingStarted: state.decodingStarted,
        byId: (0, _extends3.default)({}, state.byId, {

          // add new key to set of keys already defined
          [id]: [...new _set2.default([
          //set for uniqueness
          ...(state.byId[id] || []), key])]
        })
      };

    case actions.RESET:
      return DEFAULT_MAPPING_KEYS;

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappingKeys
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(17);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(62);

var _from2 = _interopRequireDefault(_from);

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

exports.callstack = callstack;

var _redux = __webpack_require__(5);

var _actions = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      {
        const { contractName, raw, compiler } = action;
        const context = (0, _helpers.keccak256)(raw);

        return (0, _extends3.default)({}, state, {

          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context] || {}, {

              contractName,
              context,
              compiler
            })
          })
        });
      }

    /*
     * Adding binary for a context
     */
    case actions.ADD_BINARY:
      {
        const { context, binary } = action;

        if (state.byBinary[binary]) {
          return state;
        }

        return {
          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context], {

              binary
            })
          }),

          byBinary: (0, _extends3.default)({}, state.byBinary, {

            [binary]: { context: context }
          })
        };
      }

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { address, context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts,
  instances
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      const address = action.address;
      return state.concat([{ address }]);

    case actions.CREATE:
      const binary = action.binary;
      return state.concat([{ binary }]);

    case actions.RETURN:
      //HACK: pop the stack, UNLESS that would leave it empty (this will only
      //happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
      return [state[0]]; //leave the initial call still on the stack

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(6);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps(state = DEFAULT_SOURCEMAPS, action) {
  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      let { binary, sourceMap } = action;
      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: {
            context,
            sourceMap
          }
        })
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources,
  sourceMaps
});

function functionDepth(state = 0, action) {
  switch (action.type) {
    case actions.JUMP:
      const delta = spelunk(action.jumpDirection);
      return state + delta;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump === "i") {
    return 1;
  } else if (jump === "o") {
    return -1;
  } else if (jump === "2") {
    return 2; //HACK WORKAROUND
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepth
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.finished = finished;
exports.steps = steps;

var _redux = __webpack_require__(5);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  if (action.type === actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(5);

var _actions = __webpack_require__(19);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers"); //eslint-disable-line no-unused-vars

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints
});

exports.default = reducer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], (instances, contexts, sources, sourceMaps) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let { contractName, binary } = contexts[context];
      let { sourceMap } = sourceMaps[context] || {};

      let { source } = sourceMap ?
      // look for source ID between second and third colons (HACK)
      sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {};

      return {
        [address]: {
          contractName, source, binary
        }
      };
    })))

  },

  /**
   * session.transaction (namespace)
   */
  transaction: {

    /**
     * session.transaction (selector)
     * contains the web3 transaction object
     */
    _: state => state.session.transaction,

    /**
     * session.transaction.receipt
     * contains the web3 receipt object
     */
    receipt: state => state.session.receipt

  }

});

exports.default = session;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIGI0NzU2YTUwOTZhNWZjMzU3NGUwIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIiIsImV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwiZXh0ZXJuYWwgXCJyZWR1eFwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiIiwibGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9ldm0vc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3RyYWNlL2FjdGlvbnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIiLCJsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL2RhdGEvc2FnYXMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIiIsImxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImpzb24tcG9pbnRlclwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIiIsImxpYi9hc3QvbWFwLmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZXJcIiIsImxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvdHJhY2Uvc2FnYXMvaW5kZXguanMiLCJsaWIvZXZtL3NhZ2FzL2luZGV4LmpzIiwibGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L2FjdGlvbnMvaW5kZXguanMiLCJsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCIvVXNlcnMvdHlsZXIvcHJvamVjdHMvdHJ1ZmZsZS9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL2RlYnVnZ2VyLmpzIiwibGliL2RlYnVnZ2VyLmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWV4cGVjdFwiIiwibGliL3Nlc3Npb24vaW5kZXguanMiLCJsaWIvc3RvcmUvaW5kZXguanMiLCJsaWIvc3RvcmUvcHJvZHVjdGlvbi5qcyIsImxpYi9zdG9yZS9jb21tb24uanMiLCJleHRlcm5hbCBcInJlZHV4LXNhZ2FcIiIsImV4dGVybmFsIFwicmVkdXgtY2xpLWxvZ2dlclwiIiwiL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIi9Vc2Vycy90eWxlci9wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwiL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwiL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsImV4dGVybmFsIFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIiIsIi9Vc2Vycy90eWxlci9wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzIiwiL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qcyIsImV4dGVybmFsIFwiZmFzdC1sZXZlbnNodGVpblwiIiwiL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiLCJsaWIvc2Vzc2lvbi9zYWdhcy9pbmRleC5qcyIsImxpYi9hc3Qvc2FnYXMvaW5kZXguanMiLCJsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImxpYi93ZWIzL3NhZ2FzL2luZGV4LmpzIiwibGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImxpYi93ZWIzL2FkYXB0ZXIuanMiLCJleHRlcm5hbCBcIndlYjNcIiIsImxpYi9zZXNzaW9uL3JlZHVjZXJzLmpzIiwibGliL2RhdGEvcmVkdWNlcnMuanMiLCJsaWIvZXZtL3JlZHVjZXJzLmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiIiwibGliL3NvbGlkaXR5L3JlZHVjZXJzLmpzIiwibGliL3RyYWNlL3JlZHVjZXJzLmpzIiwibGliL2NvbnRyb2xsZXIvcmVkdWNlcnMuanMiLCJsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJEZWJ1Z2dlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGI0NzU2YTUwOTZhNWZjMzU3NGUwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGVidWdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkZWJ1Z1wiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4TmFtZShwcmVmaXgsIGZuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJuYW1lXCIsIHtcbiAgICB2YWx1ZTogYCR7cHJlZml4fS4ke2ZuLm5hbWV9YCxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEByZXR1cm4gMHgtcHJlZml4IHN0cmluZyBvZiBrZWNjYWsyNTYgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHV0aWxzLkNvbnZlcnNpb24udG9IZXhTdHJpbmcodXRpbHMuRVZNLmtlY2NhazI1NiguLi5hcmdzKSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm4gYSBzdGFibGUgaGFzaCBieSBmaXJzdCBydW5uaW5nIGl0IHRocm91Z2ggYSBzdGFibGVcbiAqIHN0cmluZ2lmeSBvcGVyYXRpb24gYmVmb3JlIGhhc2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZUtlY2NhazI1NihvYmopIHtcbiAgcmV0dXJuIGtlY2NhazI1Nih7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBzdHJpbmdpZnkob2JqKSB9KTtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW1lbW9uaWMsIGRldGVybWluZSB3aGV0aGVyIGl0J3MgdGhlIG1uZW1vbmljIG9mIGEgY2FsbGluZ1xuICogaW5zdHJ1Y3Rpb24gKGRvZXMgTk9UIGluY2x1ZGUgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgY2FsbHMgPSBbXCJDQUxMXCIsIFwiREVMRUdBVEVDQUxMXCIsIFwiU1RBVElDQ0FMTFwiLCBcIkNBTExDT0RFXCJdO1xuICByZXR1cm4gY2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogR2l2ZW4gYSBtbWVtb25pYywgZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyB0aGUgbW5lbW9uaWMgb2YgYSBjcmVhdGlvblxuICogaW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ3JlYXRlTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgY3JlYXRlcyA9IFtcIkNSRUFURVwiLCBcIkNSRUFURTJcIl07XG4gIHJldHVybiBjcmVhdGVzLmluY2x1ZGVzKG9wKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvaGVscGVycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlc2VsZWN0LXRyZWVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCJcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYS9lZmZlY3RzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCJcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eFwiXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIlxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzb2xpZGl0eTpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQgU29saWRpdHlVdGlscyBmcm9tIFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiO1xuaW1wb3J0IENvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuaW1wb3J0IHsgZmluZFJhbmdlIH0gZnJvbSBcImxpYi9hc3QvbWFwXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VSYW5nZShpbnN0cnVjdGlvbiA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGluc3RydWN0aW9uLnN0YXJ0IHx8IDAsXG4gICAgbGVuZ3RoOiBpbnN0cnVjdGlvbi5sZW5ndGggfHwgMCxcbiAgICBsaW5lczogaW5zdHJ1Y3Rpb24ucmFuZ2UgfHwge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNvbHVtbjogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubGV0IHNvbGlkaXR5ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHNvbGlkaXR5LnN0YXRlXG4gICAqL1xuICBzdGF0ZTogc3RhdGUgPT4gc3RhdGUuc29saWRpdHksXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5zb3VyY2VzLmJ5SWQpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuaW5mby5zb3VyY2VNYXBzXG4gICAgICovXG4gICAgc291cmNlTWFwczogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uc291cmNlTWFwcy5ieUNvbnRleHQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZU1hcFxuICAgICAqL1xuICAgIHNvdXJjZU1hcDogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5jb250ZXh0LCBcIi9pbmZvL3NvdXJjZU1hcHNcIl0sXG5cbiAgICAgICh7IGNvbnRleHQgfSwgc291cmNlTWFwcykgPT4gc291cmNlTWFwc1tjb250ZXh0XSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBzdGF0ZSA9PiBzdGF0ZS5zb2xpZGl0eS5wcm9jLmZ1bmN0aW9uRGVwdGgsXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGluc3RydWN0aW9uczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3NvdXJjZXNcIiwgZXZtLmN1cnJlbnQuY29udGV4dCwgXCIuL3NvdXJjZU1hcFwiXSxcblxuICAgICAgKHNvdXJjZXMsIHsgYmluYXJ5IH0sIHsgc291cmNlTWFwIH0pID0+IHtcbiAgICAgICAgaWYgKCFiaW5hcnkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gQ29kZVV0aWxzLnBhcnNlQ29kZShiaW5hcnkpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgLy8gTGV0J3MgY3JlYXRlIGEgc291cmNlIG1hcCB0byB1c2Ugc2luY2Ugbm9uZSBleGlzdHMuIFRoaXMgc291cmNlIG1hcFxuICAgICAgICAgIC8vIG1hcHMganVzdCBhcyBtYW55IHJhbmdlcyBhcyB0aGVyZSBhcmUgaW5zdHJ1Y3Rpb25zLCBhbmQgZW5zdXJlcyBldmVyeVxuICAgICAgICAgIC8vIGluc3RydWN0aW9uIGlzIG1hcmtlZCBhcyBcImp1bXBpbmcgb3V0XCIuIFRoaXMgd2lsbCBlbnN1cmUgYWxsXG4gICAgICAgICAgLy8gYXZhaWxhYmxlIGRlYnVnZ2VyIGNvbW1hbmRzIHN0ZXAgb25lIGluc3RydWN0aW9uIGF0IGEgdGltZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMga2luZG9mIGEgaGFjazsgcGVyaGFwcyB0aGlzIHNob3VsZCBiZSBicm9rZW4gb3V0IGludG8gc2VwYXJhdGVcbiAgICAgICAgICAvLyBjb250ZXh0IHR5cGVzLiBUT0RPXG4gICAgICAgICAgc291cmNlTWFwID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc291cmNlTWFwICs9IGkgKyBcIjpcIiArIGkgKyBcIjoxOi0xO1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lQW5kQ29sdW1uTWFwcGluZ3MgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHNvdXJjZXMpLm1hcCgoW2lkLCB7IHNvdXJjZSB9XSkgPT4gKHtcbiAgICAgICAgICAgIFtpZF06IFNvbGlkaXR5VXRpbHMuZ2V0Q2hhcmFjdGVyT2Zmc2V0VG9MaW5lQW5kQ29sdW1uTWFwcGluZyhcbiAgICAgICAgICAgICAgc291cmNlIHx8IFwiXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGh1bWFuUmVhZGFibGVTb3VyY2VNYXAgPSBTb2xpZGl0eVV0aWxzLmdldEh1bWFuUmVhZGFibGVTb3VyY2VNYXAoXG4gICAgICAgICAgc291cmNlTWFwXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHByaW1hcnlGaWxlID0gaHVtYW5SZWFkYWJsZVNvdXJjZU1hcFswXS5maWxlO1xuICAgICAgICBkZWJ1ZyhcInByaW1hcnlGaWxlICVvXCIsIHByaW1hcnlGaWxlKTtcblxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgLm1hcCgoaW5zdHJ1Y3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBsb29rdXAgc291cmNlIG1hcCBieSBpbmRleCBhbmQgYWRkIGBpbmRleGAgcHJvcGVydHkgdG9cbiAgICAgICAgICAgIC8vIGluc3RydWN0aW9uXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBodW1hblJlYWRhYmxlU291cmNlTWFwW2luZGV4XSB8fCB7fTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IHsgLi4uaW5zdHJ1Y3Rpb24sIGluZGV4IH0sXG4gICAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoKHsgaW5zdHJ1Y3Rpb24sIHNvdXJjZU1hcCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIG1hcCBpbmZvcm1hdGlvbiB0byBpbnN0cnVjdGlvbiwgb3IgZGVmYXVsdHNcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAganVtcCxcbiAgICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgICBmaWxlID0gcHJpbWFyeUZpbGVcbiAgICAgICAgICAgIH0gPSBzb3VyY2VNYXA7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5kQ29sdW1uTWFwcGluZyA9IGxpbmVBbmRDb2x1bW5NYXBwaW5nc1tmaWxlXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgICBzdGFydDogbGluZUFuZENvbHVtbk1hcHBpbmdbc3RhcnRdIHx8IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlbmQ6IGxpbmVBbmRDb2x1bW5NYXBwaW5nW3N0YXJ0ICsgbGVuZ3RoXSB8fCB7XG4gICAgICAgICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVidWcoXCJzb3VyY2VNYXAgJW9cIiwgc291cmNlTWFwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uaW5zdHJ1Y3Rpb24sXG5cbiAgICAgICAgICAgICAganVtcCxcbiAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbnNcIl0sXG5cbiAgICAgIGluc3RydWN0aW9ucyA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBbXTtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICBtYXBbaW5zdHJ1Y3Rpb24ucGNdID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbGwgaW4gZ2FwcyBpbiBtYXAgYnkgZGVmYXVsdGluZyB0byB0aGUgbGFzdCBrbm93biBpbnN0cnVjdGlvblxuICAgICAgICBsZXQgbGFzdFNlZW4gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBbcGMsIGluc3RydWN0aW9uXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBsYXN0U2VlbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBbcGNdID0gbGFzdFNlZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXCIsIGV2bS5jdXJyZW50LnN0ZXAucHJvZ3JhbUNvdW50ZXJdLFxuXG4gICAgICAobWFwLCBwYykgPT4gbWFwW3BjXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVxuICAgICAqL1xuICAgIHNvdXJjZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3NvdXJjZXNcIiwgXCIuL2luc3RydWN0aW9uXCJdLFxuXG4gICAgICAoc291cmNlcywgeyBmaWxlOiBpZCB9KSA9PiBzb3VyY2VzW2lkXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgZ2V0U291cmNlUmFuZ2UpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxcbiAgICAgKi9cbiAgICBpc1NvdXJjZVJhbmdlRmluYWw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIixcbiAgICAgICAgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcixcbiAgICAgICAgZXZtLm5leHQuc3RlcC5wcm9ncmFtQ291bnRlclxuICAgICAgXSxcblxuICAgICAgKG1hcCwgY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIW1hcFtuZXh0XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG1hcFtjdXJyZW50XTtcbiAgICAgICAgbmV4dCA9IG1hcFtuZXh0XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGN1cnJlbnQuc3RhcnQgIT0gbmV4dC5zdGFydCB8fFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICE9IG5leHQubGVuZ3RoIHx8XG4gICAgICAgICAgY3VycmVudC5maWxlICE9IG5leHQuZmlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXG4gICAgICovXG4gICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoeyBsaW5lcyB9KSA9PiBsaW5lcy5zdGFydC5saW5lICE9IGxpbmVzLmVuZC5saW5lXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpc0p1bXAgPT4gaXNKdW1wKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvblxuICAgICAqL1xuICAgIGp1bXBEaXJlY3Rpb246IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgKGkgPSB7fSkgPT4gaS5qdW1wIHx8IFwiLVwiKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbENhbGxcbiAgICAgKi9cbiAgICB3aWxsQ2FsbDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGxdLCB4ID0+IHgpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsQ3JlYXRlXG4gICAgICovXG4gICAgd2lsbENyZWF0ZTogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NyZWF0ZV0sIHggPT4geCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmNhbGxzUHJlY29tcGlsZVxuICAgICAqL1xuICAgIGNhbGxzUHJlY29tcGlsZTogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5jYWxsc1ByZWNvbXBpbGVdLCB4ID0+IHgpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsUmV0dXJuXG4gICAgICovXG4gICAgd2lsbFJldHVybjogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZ10sXG4gICAgICBpc0hhbHRpbmcgPT4gaXNIYWx0aW5nXG4gICAgKSxcblxuICAgIC8vSEFDSzogRFVQTElDQVRFIENPREUgRk9MTE9XU1xuICAgIC8vVGhlIGZvbGxvd2luZyBjb2RlIGR1cGxpY2F0ZXMgc29tZSBzZWxlY3RvcnMgaW4gYXN0LlxuICAgIC8vVGhpcyBleGlzdHMgdG8gc3VwcG9yIHRoZSBzb2xpZGl0eS5jdXJyZW50LmNvbnRyYWN0Q2FsbCB3b3JrYXJvdW5kIGJlbG93LlxuICAgIC8vVGhpcyBzaG91bGQgYmUgY2xlYW5lZCB1cCBsYXRlci5cblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQucG9pbnRlclxuICAgICAqIEhBQ0sgZHVwbGljYXRlcyBhc3QuY3VycmVudC5wb2ludGVyXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlXCIsIFwiLi9zb3VyY2VSYW5nZVwiXSxcblxuICAgICAgKHsgYXN0IH0sIHJhbmdlKSA9PiBmaW5kUmFuZ2UoYXN0LCByYW5nZS5zdGFydCwgcmFuZ2UubGVuZ3RoKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lm5vZGVcbiAgICAgKiBIQUNLIGR1cGxpY2F0ZXMgYXN0LmN1cnJlbnQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVwiLCBcIi4vcG9pbnRlclwiXSxcbiAgICAgICh7IGFzdCB9LCBwb2ludGVyKSA9PlxuICAgICAgICBwb2ludGVyID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcikgOiBqc29ucG9pbnRlci5nZXQoYXN0LCBcIlwiKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzQ29udHJhY3RDYWxsXG4gICAgICogSEFDSyBXT1JLQVJPVU5EIChvbmx5IGFwcGxpZXMgdG8gc29sYyB2ZXJzaW9uIDwwLjUuMSlcbiAgICAgKiB0aGlzIHNlbGVjdG9yIGV4aXN0cyB0byB3b3JrIGFyb3VuZCBhIHByb2JsZW0gaW4gc29sY1xuICAgICAqIGl0IGF0dGVtcHRzIHRvIGRldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBjb250cmFjdCBtZXRob2QgY2FsbFxuICAgICAqIChvciBsaWJyYXJ5IG1ldGhvZCBjYWxsKVxuICAgICAqIGl0IHdpbGwgbm90IHN1Y2Nlc3NmdWxseSBkZXRlY3QgdGhpcyBpZiB0aGUgbWV0aG9kIHdhcyBmaXJzdCBwbGFjZWQgaW4gYVxuICAgICAqIGZ1bmN0aW9uIHZhcmlhYmxlLCBvbmx5IGlmIGl0IGlzIGJlaW5nIGNhbGxlZCBkaXJlY3RseVxuICAgICAqL1xuICAgIGlzQ29udHJhY3RDYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9ub2RlXCJdLFxuICAgICAgbm9kZSA9PlxuICAgICAgICBub2RlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gXCJGdW5jdGlvbkNhbGxcIiAmJlxuICAgICAgICBub2RlLmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBub2RlLmV4cHJlc3Npb24ubm9kZVR5cGUgPT09IFwiTWVtYmVyQWNjZXNzXCIgJiZcbiAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc0NvbnRyYWN0KG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uKSB8fFxuICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNDb250cmFjdFR5cGUobm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24pKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lm5lZWRzRnVuY3Rpb25EZXB0aFdvcmthcm91bmRcbiAgICAgKiBIQUNLXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgc29saWRpdHkgdmVyc2lvbiB1c2VkIGZvciB0aGUgY29udHJhY3QgYWJvdXQgdG8gYmVcbiAgICAgKiBjYWxsZWQgd2FzIDwwLjUuMSwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHRoZSBhYm92ZSB3b3JrYXJvdW5kXG4gICAgICogT25seSBjYWxsIHRoaXMgaWYgdGhlIGN1cnJlbnQgc3RlcCBpcyBhIGNhbGwgb3IgY3JlYXRlIVxuICAgICAqL1xuICAgIG5lZWRzRnVuY3Rpb25EZXB0aFdvcmthcm91bmQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbZXZtLmN1cnJlbnQuc3RlcC5jYWxsQ29udGV4dF0sXG4gICAgICBjb250ZXh0ID0+XG4gICAgICAgIGNvbnRleHQuY29tcGlsZXIgIT09IHVuZGVmaW5lZCAmJiAvL3dvdWxkIGJlIHVuZGVmaW5lZCBmb3IgZS5nLiBhIHByZWNvbXBpbGVcbiAgICAgICAgY29udGV4dC5jb21waWxlci5uYW1lID09PSBcInNvbGNcIiAmJlxuICAgICAgICBzZW12ZXIuc2F0aXNmaWVzKGNvbnRleHQuY29tcGlsZXIudmVyc2lvbiwgXCI8MC41LjFcIilcbiAgICApXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2xpZGl0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmV2bTpzZWxlY3RvcnNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBsZXZlbnNodGVpbiBmcm9tIFwiZmFzdC1sZXZlbnNodGVpblwiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHsgaXNDYWxsTW5lbW9uaWMsIGlzQ3JlYXRlTW5lbW9uaWMgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmZ1bmN0aW9uIGZpbmRDb250ZXh0KHsgYWRkcmVzcywgYmluYXJ5IH0sIGluc3RhbmNlcywgc2VhcmNoLCBjb250ZXh0cykge1xuICBsZXQgcmVjb3JkO1xuICBpZiAoYWRkcmVzcykge1xuICAgIHJlY29yZCA9IGluc3RhbmNlc1thZGRyZXNzXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgcmV0dXJuIHsgYWRkcmVzcyB9O1xuICAgIH1cbiAgICBiaW5hcnkgPSByZWNvcmQuYmluYXJ5O1xuICB9IGVsc2Uge1xuICAgIHJlY29yZCA9IHNlYXJjaChiaW5hcnkpO1xuICB9XG5cbiAgbGV0IGNvbnRleHQgPSBjb250ZXh0c1socmVjb3JkIHx8IHt9KS5jb250ZXh0XTtcblxuICByZXR1cm4ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbi8qKlxuICogY3JlYXRlIEVWTS1sZXZlbCBzZWxlY3RvcnMgZm9yIGEgZ2l2ZW4gdHJhY2Ugc3RlcCBzZWxlY3RvclxuICogbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBzZWxlY3RvcnMgdG8gaW5jbHVkZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGVwU2VsZWN0b3JzKHN0ZXAsIHN0YXRlID0gbnVsbCkge1xuICBsZXQgYmFzZSA9IHtcbiAgICAvKipcbiAgICAgKiAudHJhY2VcbiAgICAgKlxuICAgICAqIHRyYWNlIHN0ZXAgaW5mbyByZWxhdGVkIHRvIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRyYWNlOiBjcmVhdGVMZWFmKFtzdGVwXSwgKHsgZ2FzQ29zdCwgb3AsIHBjIH0pID0+ICh7IGdhc0Nvc3QsIG9wLCBwYyB9KSksXG5cbiAgICAvKipcbiAgICAgKiAucHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBwcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IHN0ZXAucGMpLFxuXG4gICAgLyoqXG4gICAgICogLmlzSnVtcFxuICAgICAqL1xuICAgIGlzSnVtcDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sXG4gICAgICBzdGVwID0+IHN0ZXAub3AgIT0gXCJKVU1QREVTVFwiICYmIHN0ZXAub3AuaW5kZXhPZihcIkpVTVBcIikgPT0gMFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDYWxsXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBvcGNvZGUgd2lsbCBzd2l0Y2ggdG8gYW5vdGhlciBjYWxsaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBpc0NhbGw6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBpc0NhbGxNbmVtb25pYyhzdGVwLm9wKSksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDcmVhdGVcbiAgICAgKi9cbiAgICBpc0NyZWF0ZTogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IGlzQ3JlYXRlTW5lbW9uaWMoc3RlcC5vcCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzSGFsdGluZ1xuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgaW5zdHJ1Y3Rpb24gaGFsdHMgb3IgcmV0dXJucyBmcm9tIGEgY2FsbGluZyBjb250ZXh0XG4gICAgICovXG4gICAgaXNIYWx0aW5nOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSxcbiAgICAgIHN0ZXAgPT4gc3RlcC5vcCA9PSBcIlNUT1BcIiB8fCBzdGVwLm9wID09IFwiUkVUVVJOXCJcbiAgICApXG4gIH07XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgY29uc3QgaXNSZWxhdGl2ZSA9IHBhdGggPT5cbiAgICAgIHR5cGVvZiBwYXRoID09IFwic3RyaW5nXCIgJiZcbiAgICAgIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIuLi9cIikpO1xuXG4gICAgaWYgKGlzUmVsYXRpdmUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZSA9IGAuLi8ke3N0YXRlfWA7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihiYXNlLCB7XG4gICAgICAvKipcbiAgICAgICAqIC5jYWxsQWRkcmVzc1xuICAgICAgICpcbiAgICAgICAqIGFkZHJlc3MgdHJhbnNmZXJyZWQgdG8gYnkgY2FsbCBvcGVyYXRpb25cbiAgICAgICAqL1xuICAgICAgY2FsbEFkZHJlc3M6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDYWxsXCIsIFwiLi90cmFjZVwiLCBzdGF0ZV0sXG5cbiAgICAgICAgKG1hdGNoZXMsIHN0ZXAsIHsgc3RhY2sgfSkgPT4ge1xuICAgICAgICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBsZXQgYWRkcmVzcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY3JlYXRlQmluYXJ5XG4gICAgICAgKlxuICAgICAgICogYmluYXJ5IGNvZGUgdG8gZXhlY3V0ZSB2aWEgY3JlYXRlIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjcmVhdGVCaW5hcnk6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDcmVhdGVcIiwgXCIuL3RyYWNlXCIsIHN0YXRlXSxcblxuICAgICAgICAobWF0Y2hlcywgc3RlcCwgeyBzdGFjaywgbWVtb3J5IH0pID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBjb2RlIHRoYXQncyBnb2luZyB0byBiZSBjcmVhdGVkIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDNdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxDb250ZXh0XG4gICAgICAgKlxuICAgICAgICogY29udGV4dCBmb3Igd2hhdCB3ZSdyZSBhYm91dCB0byBjYWxsIGludG8gKG9yIGNyZWF0ZSlcbiAgICAgICAqL1xuICAgICAgY2FsbENvbnRleHQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi4vY2FsbEFkZHJlc3NcIixcbiAgICAgICAgICBcIi4vY3JlYXRlQmluYXJ5XCIsXG4gICAgICAgICAgXCIvaW5mby9pbnN0YW5jZXNcIixcbiAgICAgICAgICBcIi9pbmZvL2JpbmFyaWVzL3NlYXJjaFwiLFxuICAgICAgICAgIFwiL2luZm8vY29udGV4dHNcIlxuICAgICAgICBdLFxuICAgICAgICAoYWRkcmVzcywgYmluYXJ5LCBpbnN0YW5jZXMsIHNlYXJjaCwgY29udGV4dHMpID0+XG4gICAgICAgICAgZmluZENvbnRleHQoeyBhZGRyZXNzLCBiaW5hcnkgfSwgaW5zdGFuY2VzLCBzZWFyY2gsIGNvbnRleHRzKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbHNQcmVjb21waWxlXG4gICAgICAgKlxuICAgICAgICogaXMgdGhlIGNhbGwgYWRkcmVzcyB0byBhIHByZWNvbXBpbGVkIGNvbnRyYWN0P1xuICAgICAgICogSEFDS1xuICAgICAgICovXG4gICAgICBjYWxsc1ByZWNvbXBpbGU6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vY2FsbEFkZHJlc3NcIiwgXCIvaW5mby9jb250ZXh0c1wiLCBcIi9pbmZvL2luc3RhbmNlc1wiXSxcblxuICAgICAgICAoYWRkcmVzcywgY29udGV4dHMsIGluc3RhbmNlcykgPT4ge1xuICAgICAgICAgIGlmICghYWRkcmVzcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBpbnN0YW5jZXNbYWRkcmVzc10gfHwge307XG4gICAgICAgICAgbGV0IHsgYmluYXJ5IH0gPSBjb250ZXh0c1tjb250ZXh0XSB8fCB7fTtcbiAgICAgICAgICByZXR1cm4gIWJpbmFyeTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGV2bSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBldm0uc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5ldm0sXG5cbiAgLyoqXG4gICAqIGV2bS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uY29udGV4dHNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uY29udGV4dHMuYnlDb250ZXh0KSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmluc3RhbmNlc1xuICAgICAqL1xuICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uaW5zdGFuY2VzLmJ5QWRkcmVzcyksXG5cbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5iaW5hcmllc1xuICAgICAqL1xuICAgIGJpbmFyaWVzOiB7XG4gICAgICBfOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5jb250ZXh0cy5ieUJpbmFyeSksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBmdW5jdGlvbiAoYmluYXJ5KSA9PiBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIHNlYXJjaDogY3JlYXRlTGVhZihbXCIuL19cIl0sIGJpbmFyaWVzID0+IGJpbmFyeSA9PiB7XG4gICAgICAgIC8vIHNlYXJjaCBmb3IgYSBnaXZlbiBiaW5hcnkgYmFzZWQgb24gbGV2ZW5zaHRlaW4gZGlzdGFuY2VzIHRvXG4gICAgICAgIC8vIGV4aXN0aW5nIChrbm93bikgY29udGV4dCBiaW5hcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbGV2ZW5zaHRlaW4gZGlzdGFuY2UgaXMgdGhlIG51bWJlciBvZiB0ZXh0dWFsIG1vZGlmaWNhdGlvbnNcbiAgICAgICAgLy8gKGluc2VydCwgY2hhbmdlLCBkZWxldGUpIHJlcXVpcmVkIHRvIGNvbnZlcnQgc3RyaW5nIGEgdG8gYlxuICAgICAgICAvL1xuICAgICAgICAvLyBmaWx0ZXIgYnkgYSBwZXJjZW50YWdlIHRocmVzaG9sZFxuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjI1O1xuXG4gICAgICAgIC8vIHNraXAgbGV2ZW5zaHRlaW4gY2hlY2sgZm9yIHVuZGVmaW5lZCBiaW5hcmllc1xuICAgICAgICBpZiAoIWJpbmFyeSB8fCBiaW5hcnkgPT0gXCIweDBcIikge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBPYmplY3QuZW50cmllcyhiaW5hcmllcylcbiAgICAgICAgICAubWFwKChba25vd25CaW5hcnksIHsgY29udGV4dCB9XSkgPT4gKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBkaXN0YW5jZTogbGV2ZW5zaHRlaW4uZ2V0KGtub3duQmluYXJ5LCBiaW5hcnkpXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgLmZpbHRlcigoeyBkaXN0YW5jZSB9KSA9PiBkaXN0YW5jZSA8PSBiaW5hcnkubGVuZ3RoICogdGhyZXNob2xkKVxuICAgICAgICAgIC5zb3J0KCh7IGRpc3RhbmNlOiBhIH0sIHsgZGlzdGFuY2U6IGIgfSkgPT4gYSAtIGIpO1xuXG4gICAgICAgIGlmIChyZXN1bHRzWzBdKSB7XG4gICAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSByZXN1bHRzWzBdO1xuICAgICAgICAgIHJldHVybiB7IGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0uY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNhbGxzdGFja1xuICAgICAqL1xuICAgIGNhbGxzdGFjazogc3RhdGUgPT4gc3RhdGUuZXZtLnByb2MuY2FsbHN0YWNrLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbFxuICAgICAqL1xuICAgIGNhbGw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2NhbGxzdGFja1wiXSxcblxuICAgICAgc3RhY2sgPT4gKHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIDoge30pXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNyZWF0aW9uRGVwdGhcbiAgICAgKiBob3cgbWFueSBjcmVhdGlvbiBjYWxscyBhcmUgY3VycmVudGx5IG9uIHRoZSBjYWxsIHN0YWNrP1xuICAgICAqL1xuICAgIGNyZWF0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2NhbGxzdGFja1wiXSxcblxuICAgICAgc3RhY2sgPT4gc3RhY2suZmlsdGVyKGNhbGwgPT4gY2FsbC5hZGRyZXNzID09PSB1bmRlZmluZWQpLmxlbmd0aFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb250ZXh0XG4gICAgICovXG4gICAgY29udGV4dDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbFwiLCBcIi9pbmZvL2luc3RhbmNlc1wiLCBcIi9pbmZvL2JpbmFyaWVzL3NlYXJjaFwiLCBcIi9pbmZvL2NvbnRleHRzXCJdLFxuICAgICAgZmluZENvbnRleHRcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBpbmZvOiBhcyBvZiBsYXN0IG9wZXJhdGlvbiwgYmVmb3JlIG9wIGRlZmluZWQgaW4gc3RlcFxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5bXCJkZXB0aFwiLCBcImVycm9yXCIsIFwiZ2FzXCIsIFwibWVtb3J5XCIsIFwic3RhY2tcIiwgXCJzdG9yYWdlXCJdLm1hcChwYXJhbSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5zdGVwXSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGVwXG4gICAgICovXG4gICAgc3RlcDogY3JlYXRlU3RlcFNlbGVjdG9ycyh0cmFjZS5zdGVwLCBcIi4vc3RhdGVcIilcbiAgfSxcblxuICAvKipcbiAgICogZXZtLm5leHRcbiAgICovXG4gIG5leHQ6IHtcbiAgICAvKipcbiAgICAgKiBldm0ubmV4dC5zdGF0ZVxuICAgICAqXG4gICAgICogZXZtIHN0YXRlIGFzIGEgcmVzdWx0IG9mIG5leHQgc3RlcCBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4uW1wiZGVwdGhcIiwgXCJlcnJvclwiLCBcImdhc1wiLCBcIm1lbW9yeVwiLCBcInN0YWNrXCIsIFwic3RvcmFnZVwiXS5tYXAocGFyYW0gPT4gKHtcbiAgICAgICAgW3BhcmFtXTogY3JlYXRlTGVhZihbdHJhY2UubmV4dF0sIHN0ZXAgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApLFxuXG4gICAgc3RlcDogY3JlYXRlU3RlcFNlbGVjdG9ycyh0cmFjZS5uZXh0LCBcIi4vc3RhdGVcIilcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGV2bTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBTQVZFX1NURVBTID0gXCJTQVZFX1NURVBTXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVN0ZXBzKHN0ZXBzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEVQUyxcbiAgICBzdGVwc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9BRERSRVNTRVMgPSBcIlJFQ0VJVkVfQUREUkVTU0VTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0FERFJFU1NFUyxcbiAgICBhZGRyZXNzZXNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IE5FWFQgPSBcIk5FWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBORVhUIH07XG59XG5cbmV4cG9ydCBjb25zdCBUSUNLID0gXCJUSUNLXCI7XG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcbiAgcmV0dXJuIHsgdHlwZTogVElDSyB9O1xufVxuXG5leHBvcnQgY29uc3QgVE9DSyA9IFwiVE9DS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRvY2soKSB7XG4gIHJldHVybiB7IHR5cGU6IFRPQ0sgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVORF9PRl9UUkFDRSA9IFwiRU9UXCI7XG5leHBvcnQgZnVuY3Rpb24gZW5kVHJhY2UoKSB7XG4gIHJldHVybiB7IHR5cGU6IEVORF9PRl9UUkFDRSB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlRSQUNFX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL2FjdGlvbnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCJcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBTVEFSVCA9IFwiU0VTU0lPTl9TVEFSVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVCxcbiAgICB0eEhhc2gsXG5wcm92aWRlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVBRFkgPSBcIlNFU1NJT05fUkVBRFlcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkeSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUFEWSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJTRVNTSU9OX0VSUk9SXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUixcbiAgICBlcnJvclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDT1JEX0NPTlRSQUNUUyA9IFwiUkVDT1JEX0NPTlRSQUNUU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZENvbnRyYWN0cyhjb250ZXh0cywgc291cmNlcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ09SRF9DT05UUkFDVFMsXG4gICAgY29udGV4dHMsXG5zb3VyY2VzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTQVZFX1RSQU5TQUNUSU9OID0gXCJTQVZFX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9UUkFOU0FDVElPTixcbiAgICB0cmFuc2FjdGlvblxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9SRUNFSVBUID0gXCJTQVZFX1JFQ0VJUFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlUmVjZWlwdChyZWNlaXB0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9SRUNFSVBULFxuICAgIHJlY2VpcHRcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHsgZmluZFJhbmdlIH0gZnJvbSBcIi4uL21hcFwiO1xuXG5cbi8qKlxuICogYXN0XG4gKi9cbmNvbnN0IGFzdCA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBhc3Qudmlld3NcbiAgICovXG4gIHZpZXdzOiB7XG4gICAgLyoqXG4gICAgICogYXN0LnZpZXdzLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLCBzb3VyY2VzID0+IHNvdXJjZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGFzdC5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG5cbiAgICAvKipcbiAgICAgKiBhc3QuY3VycmVudC50cmVlXG4gICAgICpcbiAgICAgKiBhc3QgZm9yIGN1cnJlbnQgc291cmNlXG4gICAgICovXG4gICAgdHJlZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LnNvdXJjZV0sICh7YXN0fSkgPT4gYXN0XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LmluZGV4XG4gICAgICpcbiAgICAgKiBzb3VyY2UgSURcbiAgICAgKi9cbiAgICBpbmRleDogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LnNvdXJjZV0sICh7aWR9KSA9PiBpZFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBhc3QuY3VycmVudC5wb2ludGVyXG4gICAgICpcbiAgICAgKiBqc29ucG9pbnRlciBmb3IgY3VycmVudCBhc3Qgbm9kZVxuICAgICAqL1xuICAgIHBvaW50ZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyZWVcIiwgc29saWRpdHkuY3VycmVudC5zb3VyY2VSYW5nZV0sXG5cbiAgICAgIChhc3QsIHJhbmdlKSA9PiBmaW5kUmFuZ2UoYXN0LCByYW5nZS5zdGFydCwgcmFuZ2UubGVuZ3RoKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBhc3QuY3VycmVudC5ub2RlXG4gICAgICpcbiAgICAgKiBjdXJyZW50IGFzdCBub2RlIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICBub2RlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmVlXCIsIFwiLi9wb2ludGVyXCJdLCAoYXN0LCBwb2ludGVyKSA9PlxuICAgICAgICAocG9pbnRlcilcbiAgICAgICAgICA/IGpzb25wb2ludGVyLmdldChhc3QsIHBvaW50ZXIpXG4gICAgICAgICAgOiBqc29ucG9pbnRlci5nZXQoYXN0LCBcIlwiKVxuICAgICksXG5cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvYXN0L3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmxldCB0cmFjZSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiB0cmFjZS5pbmRleFxuICAgKlxuICAgKiBjdXJyZW50IHN0ZXAgaW5kZXhcbiAgICovXG4gIGluZGV4OiAoc3RhdGUpID0+IHN0YXRlLnRyYWNlLnByb2MuaW5kZXgsXG5cbiAgLyoqXG4gICAqIHRyYWNlLmZpbmlzaGVkXG4gICAqXG4gICAqIGlzIHRoZSB0cmFjZSBmaW5pc2hlZD9cbiAgICovXG4gIGZpbmlzaGVkOiAoc3RhdGUpID0+IHN0YXRlLnRyYWNlLnByb2MuZmluaXNoZWQsXG5cbiAgLyoqXG4gICAqIHRyYWNlLnN0ZXBzXG4gICAqXG4gICAqIGFsbCB0cmFjZSBzdGVwc1xuICAgKi9cbiAgc3RlcHM6IChzdGF0ZSkgPT4gc3RhdGUudHJhY2UuaW5mby5zdGVwcyxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcHNSZW1haW5pbmdcbiAgICpcbiAgICogbnVtYmVyIG9mIHN0ZXBzIHJlbWFpbmluZyBpbiB0cmFjZVxuICAgKi9cbiAgc3RlcHNSZW1haW5pbmc6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+IHN0ZXBzLmxlbmd0aCAtIGluZGV4XG4gICksXG5cbiAgLyoqXG4gICAqIHRyYWNlLnN0ZXBcbiAgICpcbiAgICogY3VycmVudCB0cmFjZSBzdGVwXG4gICAqL1xuICBzdGVwOiBjcmVhdGVMZWFmKFxuICAgIFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLCAoc3RlcHMsIGluZGV4KSA9PiBzdGVwc1tpbmRleF1cbiAgKSxcblxuICAvKipcbiAgICogdHJhY2UubmV4dFxuICAgKlxuICAgKiBuZXh0IHRyYWNlIHN0ZXBcbiAgICogSEFDSzogaWYgYXQgdGhlIGVuZCxcbiAgICogd2Ugd2lsbCByZXR1cm4gdGhlICpzYW1lKiB0cmFjZSBzdGVwXG4gICAqL1xuICBuZXh0OiBjcmVhdGVMZWFmKFxuICAgIFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLCAoc3RlcHMsIGluZGV4KSA9PlxuICAgICAgaW5kZXggPCBzdGVwcy5sZW5ndGggLSAxID8gc3RlcHNbaW5kZXggKyAxXSA6IHN0ZXBzW2luZGV4XVxuICApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHJhY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnNhZ2FzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IHB1dCwgdGFrZUV2ZXJ5LCBzZWxlY3QsIGNhbGwsIHB1dFJlc29sdmUgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUsIHN0YWJsZUtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBkYXRhIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmltcG9ydCB7IGdldFN0b3JhZ2VBbGxvY2F0aW9ucywgcmVhZFN0YWNrIH0gZnJvbSBcInRydWZmbGUtZGVjb2RlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24qIHNjb3BlKG5vZGVJZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSB7XG4gIHlpZWxkIHB1dFJlc29sdmUoYWN0aW9ucy5zY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGRlY2xhcmUobm9kZSkge1xuICB5aWVsZCBwdXRSZXNvbHZlKGFjdGlvbnMuZGVjbGFyZShub2RlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZGVmaW5lVHlwZShub2RlKSB7XG4gIHlpZWxkIHB1dFJlc29sdmUoYWN0aW9ucy5kZWZpbmVUeXBlKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24qIHRpY2tTYWdhKCkge1xuICBsZXQgbm9kZSA9ICh5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5hc3QpKS5ub2RlO1xuICBsZXQgZGVjb2RlID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuZGVjb2Rlcik7XG4gIGxldCBzY29wZXMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZCk7XG4gIGxldCBhbGxvY2F0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLmluZm8uYWxsb2NhdGlvbnMuc3RvcmFnZSk7XG4gIGxldCBjdXJyZW50QXNzaWdubWVudHMgPSB5aWVsZCBzZWxlY3QoZGF0YS5wcm9jLmFzc2lnbm1lbnRzKTtcbiAgbGV0IGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5hZGRyZXNzKTsgLy9tYXkgYmUgdW5kZWZpbmVkXG4gIGxldCBkdW1teUFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmR1bW15QWRkcmVzcyk7XG5cbiAgZGVidWcoXCJub2RlICVvXCIsIG5vZGUpO1xuXG4gIGxldCBzdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQuc3RhdGUuc3RhY2spO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBhc3NpZ25tZW50LCBhc3NpZ25tZW50cztcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzdGFjayBpcyBvbmx5IHJlYWR5IGZvciBpbnRlcnByZXRhdGlvbiBhZnRlciB0aGUgbGFzdCBzdGVwIG9mIGVhY2hcbiAgLy8gc291cmNlIHJhbmdlXG4gIC8vXG4gIC8vIHRoZSBkYXRhIG1vZHVsZSBhbHdheXMgbG9va3MgYXQgdGhlIHJlc3VsdCBvZiBhIHBhcnRpY3VsYXIgb3Bjb2RlXG4gIC8vIChpLmUuLCB0aGUgZm9sbG93aW5nIHRyYWNlIHN0ZXAncyBzdGFjay9tZW1vcnkvc3RvcmFnZSksIHNvIHRoaXNcbiAgLy8gYXNzZXJ0cyB0aGF0IHRoZSBfY3VycmVudF8gb3BlcmF0aW9uIGlzIHRoZSBmaW5hbCBvbmUgYmVmb3JlXG4gIC8vIHByb2NlZWRpbmdcbiAgaWYgKCEoeWllbGQgc2VsZWN0KGRhdGEudmlld3MuYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZSkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgbGV0IHBhcmFtZXRlcnMgPSBub2RlLnBhcmFtZXRlcnMucGFyYW1ldGVycztcbiAgICAgIC8vbm90ZSB0aGF0IHdlIGRvICpub3QqIGluY2x1ZGUgcmV0dXJuIHBhcmFtZXRlcnMsIHNpbmNlIHRob3NlIGFyZVxuICAgICAgLy9oYW5kbGVkIGJ5IHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uIGNhc2UgKG5vLCBJIGRvbid0IGtub3cgd2h5IGl0XG4gICAgICAvL3dvcmtzIG91dCB0aGF0IHdheSlcbiAgICAgIGxldCByZXZlcnNlUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAvL3JldmVyc2UgaXMgaW4tcGxhY2UsIHNvIHdlIHVzZSBzbGljZSgpIHRvIGNsb25lIGZpcnN0XG4gICAgICBkZWJ1ZyhcInJldmVyc2VQYXJhbWV0ZXJzICVvXCIsIHBhcmFtZXRlcnMpO1xuXG4gICAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gdG9wO1xuICAgICAgYXNzaWdubWVudHMgPSB7IGJ5SWQ6IHt9IH07XG5cbiAgICAgIGZvciAobGV0IHBhcmFtZXRlciBvZiByZXZlcnNlUGFyYW1ldGVycykge1xuICAgICAgICBsZXQgd29yZHMgPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnN0YWNrU2l6ZShwYXJhbWV0ZXIpO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHtcbiAgICAgICAgICBzdGFjazoge1xuICAgICAgICAgICAgZnJvbTogY3VycmVudFBvc2l0aW9uIC0gd29yZHMgKyAxLFxuICAgICAgICAgICAgdG86IGN1cnJlbnRQb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSBtYWtlQXNzaWdubWVudChcbiAgICAgICAgICB7IGFzdElkOiBwYXJhbWV0ZXIuaWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgICAgICAgIHBvaW50ZXJcbiAgICAgICAgKTtcbiAgICAgICAgYXNzaWdubWVudHMuYnlJZFthc3NpZ25tZW50LmlkXSA9IGFzc2lnbm1lbnQ7XG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbiAtPSB3b3JkcztcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJGdW5jdGlvbiBkZWZpbml0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJDb250cmFjdERlZmluaXRpb25cIjpcbiAgICAgIGxldCBhbGxvY2F0aW9uID0gYWxsb2NhdGlvbnNbbm9kZS5pZF07XG5cbiAgICAgIGRlYnVnKFwiQ29udHJhY3QgZGVmaW5pdGlvbiBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJhbGxvY2F0aW9ucyAlT1wiLCBhbGxvY2F0aW9ucyk7XG4gICAgICBkZWJ1ZyhcImFsbG9jYXRpb24gJU9cIiwgYWxsb2NhdGlvbik7XG4gICAgICBhc3NpZ25tZW50cyA9IHsgYnlJZDoge30gfTtcbiAgICAgIGZvciAobGV0IGlkIGluIGFsbG9jYXRpb24ubWVtYmVycykge1xuICAgICAgICBpZCA9IE51bWJlcihpZCk7IC8vbm90IHN1cmUgd2h5IHdlJ3JlIGdldHRpbmcgdGhlbSBhcyBzdHJpbmdzLCBidXQuLi5cbiAgICAgICAgbGV0IGlkT2JqO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWRPYmogPSB7IGFzdElkOiBpZCwgYWRkcmVzcyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkT2JqID0geyBhc3RJZDogaWQsIGR1bW15QWRkcmVzcyB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsSWQgPSBzdGFibGVLZWNjYWsyNTYoaWRPYmopO1xuICAgICAgICAvL3dlIGRvbid0IHVzZSBtYWtlQXNzaWdubWVudCBoZXJlIGFzIHdlIGhhZCB0byBjb21wdXRlIHRoZSBJRCBhbnl3YXlcbiAgICAgICAgYXNzaWdubWVudCA9IHtcbiAgICAgICAgICAuLi5pZE9iaixcbiAgICAgICAgICBpZDogZnVsbElkLFxuICAgICAgICAgIHJlZjoge1xuICAgICAgICAgICAgLi4uKChjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSWRdIHx8IHt9KS5yZWYgfHwge30pLFxuICAgICAgICAgICAgLi4uYWxsb2NhdGlvbi5tZW1iZXJzW2lkXS5wb2ludGVyXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhc3NpZ25tZW50cy5ieUlkW2Z1bGxJZF0gPSBhc3NpZ25tZW50O1xuICAgICAgfVxuICAgICAgZGVidWcoXCJhc3NpZ25tZW50cyAlT1wiLCBhc3NpZ25tZW50cyk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgbGV0IHZhcklkID0gbm9kZS5pZDtcbiAgICAgIGRlYnVnKFwiVmFyaWFibGUgZGVjbGFyYXRpb24gY2FzZVwiKTtcbiAgICAgIGRlYnVnKFwiY3VycmVudERlcHRoICVkIHZhcklkICVkXCIsIGN1cnJlbnREZXB0aCwgdmFySWQpO1xuXG4gICAgICAvL05PVEU6IFdlJ3JlIGdvaW5nIHRvIG1ha2UgdGhlIGFzc2lnbm1lbnQgY29uZGl0aW9uYWwgaGVyZTsgaGVyZSdzIHdoeS5cbiAgICAgIC8vVGhlcmUncyBhIGJ1ZyB3aGVyZSBjYWxsaW5nIHRoZSBhdXRvZ2VuZXJhdGVkIGFjY2Vzc29yIGZvciBhIHB1YmxpY1xuICAgICAgLy9jb250cmFjdCB2YXJpYWJsZSBjYXVzZXMgdGhlIGRlYnVnZ2VyIHRvIHNlZSB0d28gYWRkaXRpb25hbFxuICAgICAgLy9kZWNsYXJhdGlvbnMgZm9yIHRoYXQgdmFyaWFibGUuLi4gd2hpY2ggdGhpcyBjb2RlIHJlYWRzIGFzIGxvY2FsXG4gICAgICAvL3ZhcmlhYmxlIGRlY2xhcmF0aW9ucy4gIFJhdGhlciB0aGFuIHByZXZlbnQgdGhpcyBhdCB0aGUgc291cmNlLCB3ZSdyZVxuICAgICAgLy9qdXN0IGdvaW5nIHRvIGNoZWNrIGZvciBpdCBoZXJlLCBieSBub3QgYWRkaW5nIGEgbG9jYWwgdmFyaWFibGUgaWYgc2FpZFxuICAgICAgLy92YXJpYWJsZSBpcyBhbHJlYWR5IGEgY29udHJhY3QgdmFyaWFibGUuXG5cbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLmJ5QXN0SWRbdmFySWRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLmJ5QXN0SWRbdmFySWRdLnNvbWUoXG4gICAgICAgICAgaWQgPT5cbiAgICAgICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2lkXS5hZGRyZXNzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2lkXS5kdW1teUFkZHJlc3MgIT09IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vb3RoZXJ3aXNlLCBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgYXNzaWdubWVudFxuICAgICAgYXNzaWdubWVudCA9IG1ha2VBc3NpZ25tZW50KFxuICAgICAgICB7IGFzdElkOiB2YXJJZCwgc3RhY2tmcmFtZTogY3VycmVudERlcHRoIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzdGFjazoge1xuICAgICAgICAgICAgZnJvbTogdG9wIC0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUobm9kZSkgKyAxLFxuICAgICAgICAgICAgdG86IHRvcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGFzc2lnbm1lbnRzID0geyBieUlkOiB7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9IH07XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkluZGV4QWNjZXNzXCI6XG4gICAgICAvLyB0byB0cmFjayBgbWFwcGluZ2AgdHlwZXMga25vd24gaW5kaWNlc1xuXG4gICAgICBkZWJ1ZyhcIkluZGV4IGFjY2VzcyBjYXNlXCIpO1xuXG4gICAgICBsZXQgYmFzZUV4cHJlc3Npb24gPSBub2RlLmJhc2VFeHByZXNzaW9uO1xuICAgICAgbGV0IGJhc2VEZWNsYXJhdGlvbklkID0gYmFzZUV4cHJlc3Npb24ucmVmZXJlbmNlZERlY2xhcmF0aW9uO1xuXG4gICAgICBsZXQgYmFzZURlY2xhcmF0aW9uID0gc2NvcGVzW2Jhc2VEZWNsYXJhdGlvbklkXS5kZWZpbml0aW9uO1xuXG4gICAgICAvL2lmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSBtYXBwaW5nLCBkb24ndCBib3RoZXIhXG4gICAgICBpZiAoIURlY29kZVV0aWxzLkRlZmluaXRpb24uaXNNYXBwaW5nKGJhc2VFeHByZXNzaW9uKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IGtleURlZmluaXRpb24gPVxuICAgICAgICBiYXNlRGVjbGFyYXRpb24ua2V5VHlwZSB8fCBiYXNlRGVjbGFyYXRpb24udHlwZU5hbWUua2V5VHlwZTtcblxuICAgICAgLy9iZWdpbiBzdWJzZWN0aW9uOiBrZXkgZGVjb2RpbmdcbiAgICAgIC8vKEkgdHJpZWQgZmFjdG9yaW5nIHRoaXMgb3V0IGludG8gaXRzIG93biBzYWdhIGJ1dCBpdCBkaWRuJ3Qgd29yayB3aGVuIElcbiAgICAgIC8vZGlkIDpQIClcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLm1hcEtleURlY29kaW5nKHRydWUpKTtcblxuICAgICAgbGV0IGluZGV4VmFsdWU7XG4gICAgICBsZXQgaW5kZXhEZWZpbml0aW9uID0gbm9kZS5pbmRleEV4cHJlc3Npb247XG5cbiAgICAgIC8vd2h5IHRoZSBsb29wPyBzZWUgdGhlIGVuZCBvZiB0aGUgYmxvY2sgaXQgaGVhZHMgdG8gZm9yIGFuIGV4cGxhbmF0b3J5XG4gICAgICAvL2NvbW1lbnRcbiAgICAgIHdoaWxlIChpbmRleFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGluZGV4SWQgPSBpbmRleERlZmluaXRpb24uaWQ7XG4gICAgICAgIC8vaW5kaWNlcyBuZWVkIHRvIGJlIGlkZW50aWZpZWQgYnkgc3RhY2tmcmFtZVxuICAgICAgICBsZXQgaW5kZXhJZE9iaiA9IHsgYXN0SWQ6IGluZGV4SWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9O1xuICAgICAgICBsZXQgZnVsbEluZGV4SWQgPSBzdGFibGVLZWNjYWsyNTYoaW5kZXhJZE9iaik7XG5cbiAgICAgICAgY29uc3QgaW5kZXhSZWZlcmVuY2UgPSAoY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbZnVsbEluZGV4SWRdIHx8IHt9KS5yZWY7XG5cbiAgICAgICAgaWYgKERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChpbmRleERlZmluaXRpb24pKSB7XG4gICAgICAgICAgLy93aGlsZSB0aGUgbWFpbiBjYXNlIGlzIHRoZSBuZXh0IG9uZSwgd2hlcmUgd2UgbG9vayBmb3IgYSBwcmlvclxuICAgICAgICAgIC8vYXNzaWdubWVudCwgd2UgbmVlZCB0aGlzIGNhc2UgKGFuZCBuZWVkIGl0IGZpcnN0KSBmb3IgdHdvIHJlYXNvbnM6XG4gICAgICAgICAgLy8xLiBzb21lIGNvbnN0YW50IGV4cHJlc3Npb25zIChzcGVjaWZpY2FsbHksIHN0cmluZyBhbmQgaGV4IGxpdGVyYWxzKVxuICAgICAgICAgIC8vYXJlbid0IHNvdXJjZW1hcHBlZCB0byBhbmQgc28gd29uJ3QgaGF2ZSBhIHByaW9yIGFzc2lnbm1lbnRcbiAgICAgICAgICAvLzIuIGlmIHRoZSBrZXkgdHlwZSBpcyBieXRlc04gYnV0IHRoZSBleHByZXNzaW9uIGlzIGNvbnN0YW50LCB0aGVcbiAgICAgICAgICAvL3ZhbHVlIHdpbGwgZ28gb24gdGhlIHN0YWNrICpsZWZ0Ki1wYWRkZWQgaW5zdGVhZCBvZiByaWdodC1wYWRkZWQsXG4gICAgICAgICAgLy9zbyBsb29raW5nIGZvciBhIHByaW9yIGFzc2lnbm1lbnQgd2lsbCByZWFkIHRoZSB3cm9uZyB2YWx1ZS5cbiAgICAgICAgICAvL3NvIGluc3RlYWQgaXQncyBwcmVmZXJhYmxlIHRvIHVzZSB0aGUgY29uc3RhbnQgZGlyZWN0bHkuXG4gICAgICAgICAgaW5kZXhWYWx1ZSA9IHlpZWxkIGNhbGwoZGVjb2RlLCBrZXlEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBpbmRleERlZmluaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleFJlZmVyZW5jZSkge1xuICAgICAgICAgIC8vaWYgYSBwcmlvciBhc3NpZ25tZW50IGlzIGZvdW5kXG4gICAgICAgICAgbGV0IHNwbGljZWREZWZpbml0aW9uO1xuICAgICAgICAgIC8vaW4gZ2VuZXJhbCwgd2Ugd2FudCB0byBkZWNvZGUgdXNpbmcgdGhlIGtleSBkZWZpbml0aW9uLCBub3QgdGhlIGluZGV4XG4gICAgICAgICAgLy9kZWZpbml0aW9uLiBob3dldmVyLCB0aGUga2V5IGRlZmluaXRpb24gbWF5IGhhdmUgdGhlIHdyb25nIGxvY2F0aW9uXG4gICAgICAgICAgLy9vbiBpdC4gIHNvLCB3aGVuIGFwcGxpY2FibGUsIHdlIHNwbGljZSB0aGUgaW5kZXggZGVmaW5pdGlvbiBsb2NhdGlvblxuICAgICAgICAgIC8vb250byB0aGUga2V5IGRlZmluaXRpb24gbG9jYXRpb24uXG4gICAgICAgICAgaWYgKERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNSZWZlcmVuY2UoaW5kZXhEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgc3BsaWNlZERlZmluaXRpb24gPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnNwbGljZUxvY2F0aW9uKFxuICAgICAgICAgICAgICBrZXlEZWZpbml0aW9uLFxuICAgICAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnJlZmVyZW5jZVR5cGUoaW5kZXhEZWZpbml0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BsaWNlZERlZmluaXRpb24gPSBrZXlEZWZpbml0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFZhbHVlID0geWllbGQgY2FsbChkZWNvZGUsIHNwbGljZWREZWZpbml0aW9uLCBpbmRleFJlZmVyZW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZWREZWNsYXJhdGlvbiAmJlxuICAgICAgICAgIHNjb3Blc1tpbmRleERlZmluaXRpb24ucmVmZXJlbmNlRGVjbGFyYXRpb25dXG4gICAgICAgICkge1xuICAgICAgICAgIC8vdGhlcmUncyBvbmUgbW9yZSByZWFzb24gd2UgbWlnaHQgaGF2ZSBmYWlsZWQgdG8gZGVjb2RlIGl0OiBpdCBtaWdodCBiZSBhXG4gICAgICAgICAgLy9jb25zdGFudCBzdGF0ZSB2YXJpYWJsZS4gIFVuZm9ydHVuYXRlbHksIHdlIGRvbid0IGtub3cgaG93IHRvIGRlY29kZSBhbGxcbiAgICAgICAgICAvL3Rob3NlIGF0IHRoZSBtb21lbnQsIGJ1dCB3ZSBjYW4gaGFuZGxlIHRoZSBvbmVzIHdlIGRvIGtub3cgaG93IHRvIGRlY29kZS5cbiAgICAgICAgICAvL0luIHRoZSBmdXR1cmUgaG9wZWZ1bGx5IHdlIHdpbGwgZGVjb2RlIGFsbCBvZiB0aGVtXG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICBcInJlZmVyZW5jZWREZWNsYXJhdGlvbiAlZFwiLFxuICAgICAgICAgICAgaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZWREZWNsYXJhdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGluZGV4Q29uc3RhbnREZWNsYXJhdGlvbiA9XG4gICAgICAgICAgICBzY29wZXNbaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZWREZWNsYXJhdGlvbl0uZGVmaW5pdGlvbjtcbiAgICAgICAgICBkZWJ1ZyhcImluZGV4Q29uc3RhbnREZWNsYXJhdGlvbiAlT1wiLCBpbmRleENvbnN0YW50RGVjbGFyYXRpb24pO1xuICAgICAgICAgIGlmIChpbmRleENvbnN0YW50RGVjbGFyYXRpb24uY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGxldCBpbmRleENvbnN0YW50RGVmaW5pdGlvbiA9IGluZGV4Q29uc3RhbnREZWNsYXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIC8vbmV4dCBsaW5lIGZpbHRlcnMgb3V0IGNvbnN0YW50cyB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1NpbXBsZUNvbnN0YW50KGluZGV4Q29uc3RhbnREZWZpbml0aW9uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGluZGV4VmFsdWUgPSB5aWVsZCBjYWxsKGRlY29kZSwga2V5RGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGluZGV4Q29uc3RhbnREZWNsYXJhdGlvbi52YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy90aGVyZSdzIHN0aWxsIG9uZSBtb3JlIHJlYXNvbiB3ZSBtaWdodCBoYXZlIGZhaWxlZCB0byBkZWNvZGUgaXQ6XG4gICAgICAgIC8vY2VydGFpbiAoc2lsZW50KSB0eXBlIGNvbnZlcnNpb25zIGFyZW4ndCBzb3VyY2VtYXBwZWQgZWl0aGVyLlxuICAgICAgICAvLyh0aGFua2Z1bGx5LCBhbnkgdHlwZSBjb252ZXJzaW9uIHRoYXQgYWN0dWFsbHkgKmRvZXMqIHNvbWV0aGluZyBzZWVtc1xuICAgICAgICAvL3RvIGJlIHNvdXJjZW1hcHBlZC4pICBTbyBpZiB3ZSd2ZSBmYWlsZWQgdG8gZGVjb2RlIGl0LCB3ZSB0cnkgYWdhaW5cbiAgICAgICAgLy93aXRoIHRoZSBhcmd1bWVudCBvZiB0aGUgdHlwZSBjb252ZXJzaW9uLCBpZiBpdCBpcyBvbmU7IHdlIGxlYXZlXG4gICAgICAgIC8vaW5kZXhWYWx1ZSB1bmRlZmluZWQgc28gdGhlIGxvb3Agd2lsbCBjb250aW51ZVxuICAgICAgICAvLyhub3RlIHRoYXQgdGhpcyBjYXNlIGlzIGxhc3QgZm9yIGEgcmVhc29uOyBpZiB0aGlzIHdlcmUgZWFybGllciwgaXRcbiAgICAgICAgLy93b3VsZCBjYXRjaCAqbm9uKi1zaWxlbnQgdHlwZSBjb252ZXJzaW9ucywgd2hpY2ggd2Ugd2FudCB0byBqdXN0IHJlYWRcbiAgICAgICAgLy9vZmYgdGhlIHN0YWNrKVxuICAgICAgICBlbHNlIGlmIChpbmRleERlZmluaXRpb24ua2luZCA9PT0gXCJ0eXBlQ29udmVyc2lvblwiKSB7XG4gICAgICAgICAgaW5kZXhEZWZpbml0aW9uID0gaW5kZXhEZWZpbml0aW9uLmFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvL290aGVyd2lzZSwgd2UndmUganVzdCB0b3RhbGx5IGZhaWxlZCB0byBkZWNvZGUgaXQsIHNvIHdlIG1hcmtcbiAgICAgICAgLy9pbmRleFZhbHVlIGFzIG51bGwgKGFzIGRpc3RpbmN0IGZyb20gdW5kZWZpbmVkKSB0byBpbmRpY2F0ZSB0aGlzLiAgSW5cbiAgICAgICAgLy90aGUgZnV0dXJlLCB3ZSBzaG91bGQgYmUgYWJsZSB0byBkZWNvZGUgYWxsIG1hcHBpbmcga2V5cywgYnV0IHdlJ3JlXG4gICAgICAgIC8vbm90IHF1aXRlIHRoZXJlIHlldCwgc29ycnkgKGJlY2F1c2Ugd2UgY2FuJ3QgeWV0IGhhbmRsZSBhbGwgY29uc3RhbnRcbiAgICAgICAgLy9zdGF0ZSB2YXJpYWJsZXMpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vbm93LCBhcyBtZW50aW9uZWQsIHJldHJ5IGluIHRoZSB0eXBlQ29udmVyc2lvbiBjYXNlXG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLm1hcEtleURlY29kaW5nKGZhbHNlKSk7XG4gICAgICAvL2VuZCBzdWJzZWN0aW9uOiBrZXkgZGVjb2RpbmdcblxuICAgICAgZGVidWcoXCJpbmRleCB2YWx1ZSAlT1wiLCBpbmRleFZhbHVlKTtcbiAgICAgIGRlYnVnKFwia2V5RGVmaW5pdGlvbiAlT1wiLCBrZXlEZWZpbml0aW9uKTtcblxuICAgICAgLy9pZiB3ZSBzdWNjZWVkZWQgYXQgZGVjb2RpbmcgaXQgLS0gaS5lLiBpdCdzIG5vdCBudWxsIC0tIHRoZW4gbWFwIGl0IVxuICAgICAgaWYgKGluZGV4VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMubWFwS2V5KGJhc2VEZWNsYXJhdGlvbklkLCBpbmRleFZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChub2RlLnR5cGVEZXNjcmlwdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcImRlY29kaW5nIGV4cHJlc3Npb24gdmFsdWUgJU9cIiwgbm9kZS50eXBlRGVzY3JpcHRpb25zKTtcbiAgICAgIGxldCBsaXRlcmFsID0gcmVhZFN0YWNrKFxuICAgICAgICBzdGFjayxcbiAgICAgICAgdG9wIC0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUobm9kZSkgKyAxLFxuICAgICAgICB0b3BcbiAgICAgICk7XG5cbiAgICAgIGRlYnVnKFwiZGVmYXVsdCBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJjdXJyZW50RGVwdGggJWQgbm9kZS5pZCAlZFwiLCBjdXJyZW50RGVwdGgsIG5vZGUuaWQpO1xuICAgICAgYXNzaWdubWVudCA9IG1ha2VBc3NpZ25tZW50KFxuICAgICAgICB7IGFzdElkOiBub2RlLmlkLCBzdGFja2ZyYW1lOiBjdXJyZW50RGVwdGggfSxcbiAgICAgICAgeyBsaXRlcmFsIH1cbiAgICAgICk7XG4gICAgICBhc3NpZ25tZW50cyA9IHsgYnlJZDogeyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfSB9O1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBsZWFybkFkZHJlc3NTYWdhKGR1bW15QWRkcmVzcywgYWRkcmVzcykge1xuICBkZWJ1ZyhcImFib3V0IHRvIGxlYXJuIGFuIGFkZHJlc3NcIik7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmxlYXJuQWRkcmVzcyhkdW1teUFkZHJlc3MsIGFkZHJlc3MpKTtcbiAgZGVidWcoXCJhZGRyZXNzIGxlYXJudFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZWNvcmRBbGxvY2F0aW9ucygpIHtcbiAgbGV0IGNvbnRyYWN0cyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnVzZXJEZWZpbmVkVHlwZXMuY29udHJhY3REZWZpbml0aW9ucyk7XG4gIGRlYnVnKFwiY29udHJhY3RzICVPXCIsIGNvbnRyYWN0cyk7XG4gIGxldCByZWZlcmVuY2VEZWNsYXJhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBkZWJ1ZyhcInJlZmVyZW5jZURlY2xhcmF0aW9ucyAlT1wiLCByZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBsZXQgc3RvcmFnZUFsbG9jYXRpb25zID0gZ2V0U3RvcmFnZUFsbG9jYXRpb25zKFxuICAgIHJlZmVyZW5jZURlY2xhcmF0aW9ucyxcbiAgICBjb250cmFjdHNcbiAgKTtcbiAgZGVidWcoXCJzdG9yYWdlQWxsb2NhdGlvbnMgJU9cIiwgc3RvcmFnZUFsbG9jYXRpb25zKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWxsb2NhdGUoc3RvcmFnZUFsbG9jYXRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50KGlkT2JqLCByZWYpIHtcbiAgbGV0IGlkID0gc3RhYmxlS2VjY2FrMjU2KGlkT2JqKTtcbiAgcmV0dXJuIHsgLi4uaWRPYmosIGlkLCByZWYgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgZnVuY3Rpb24qKCkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCogdGlja1NhZ2EoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhcIkVSUk9SOiAlT1wiLCBlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZGF0YVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCJcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIlxuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IEJFR0lOX1NURVAgPSBcIkJFR0lOX1NURVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBiZWdpblN0ZXAodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEJFR0lOX1NURVAsXG4gICAgc3RlcFR5cGU6IHR5cGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFEVkFOQ0UgPSBcIkFEVkFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICByZXR1cm4geyB0eXBlOiBBRFZBTkNFIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX05FWFQgPSBcIlNURVBfTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBOZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX05FWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfT1ZFUiB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9JTlRPID0gXCJTVEVQX0lOVE9cIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwSW50bygpIHtcbiAgcmV0dXJuIHsgdHlwZTogU1RFUF9JTlRPIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX09VVCA9IFwiU1RFUF9PVVRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3V0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX09VVCB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlJFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIklOVEVSUlVQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycnVwdCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogSU5URVJSVVBUIH07XG59XG5cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFwiQ09OVElOVUVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZVVudGlsQnJlYWtwb2ludCgpIHtcbiAgLy9cImNvbnRpbnVlXCIgaXMgbm90IGEgbGVnYWwgbmFtZVxuICByZXR1cm4geyB0eXBlOiBDT05USU5VRSB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0JSRUFLUE9JTlQgPSBcIkFERF9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0JSRUFLUE9JTlQgPSBcIlJFTU9WRV9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0FMTF9CUkVBS1BPSU5UUyA9IFwiUkVNT1ZFX0FMTF9CUkVBS1BPSU5UU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbEJyZWFrcG9pbnRzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFTU9WRV9BTExfQlJFQUtQT0lOVFNcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2VsZWN0b3JzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgeyBzdGFibGVLZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5pbXBvcnQgeyBmb3JFdm1TdGF0ZSB9IGZyb20gXCJ0cnVmZmxlLWRlY29kZXJcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVTZWxlY3RvcnMoeyBzdGFjaywgbWVtb3J5LCBzdG9yYWdlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiAuc3RhY2tcbiAgICAgKi9cbiAgICBzdGFjazogY3JlYXRlTGVhZihcbiAgICAgIFtzdGFja10sXG5cbiAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAubWVtb3J5XG4gICAgICovXG4gICAgbWVtb3J5OiBjcmVhdGVMZWFmKFxuICAgICAgW21lbW9yeV0sXG5cbiAgICAgIHdvcmRzID0+IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh3b3Jkcy5qb2luKFwiXCIpKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuc3RvcmFnZVxuICAgICAqL1xuICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RvcmFnZV0sXG5cbiAgICAgIG1hcHBpbmcgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhtYXBwaW5nKS5tYXAoKFthZGRyZXNzLCB3b3JkXSkgPT4gKHtcbiAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh3b3JkKVxuICAgICAgICAgIH0pKVxuICAgICAgICApXG4gICAgKVxuICB9O1xufVxuXG5jb25zdCBkYXRhID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgc3RhdGU6IHN0YXRlID0+IHN0YXRlLmRhdGEsXG5cbiAgLyoqXG4gICAqIGRhdGEudmlld3NcbiAgICovXG4gIHZpZXdzOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS52aWV3cy5hc3RcbiAgICAgKi9cbiAgICBhc3Q6IGNyZWF0ZUxlYWYoW2FzdC5jdXJyZW50XSwgdHJlZSA9PiB0cmVlKSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbF0sXG4gICAgICBmaW5hbCA9PiBmaW5hbFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkIChuYW1lc3BhY2UpXG4gICAgICAgKi9cbiAgICAgIGlubGluZWQ6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQgKHNlbGVjdG9yKVxuICAgICAgICAgKiBzZWUgZGF0YS5pbmZvLnNjb3BlcyBmb3IgaG93IHRoaXMgZGlmZmVycyBmcm9tIHRoZSByYXcgdmVyc2lvblxuICAgICAgICAgKi9cbiAgICAgICAgXzogY3JlYXRlTGVhZihbXCIvaW5mby9zY29wZXNcIiwgXCIuL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbmxpbmVkKS5tYXAoKFtpZCwgaW5mb10pID0+IHtcbiAgICAgICAgICAgICAgbGV0IG5ld0luZm8gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgICAgICAgbmV3SW5mby52YXJpYWJsZXMgPSBzY29wZXNbaWRdLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogbmV3SW5mbyB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQucmF3XG4gICAgICAgICAqL1xuICAgICAgICByYXc6IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL2luZm8vc2NvcGVzL3Jhd1wiLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAgICAgKHNjb3Blcywgc291cmNlcykgPT5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBlbnRyeV0pID0+ICh7XG4gICAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZW50cnksXG5cbiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LFxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wb2ludGVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLmRlY29kZXJcbiAgICAgKlxuICAgICAqIHNlbGVjdG9yIHJldHVybnMgKGFzdCBub2RlIGRlZmluaXRpb24sIGRhdGEgcmVmZXJlbmNlKSA9PiBQcm9taXNlPHZhbHVlPlxuICAgICAqL1xuICAgIGRlY29kZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiL3ZpZXdzL3JlZmVyZW5jZURlY2xhcmF0aW9uc1wiLFxuICAgICAgICBcIi9uZXh0L3N0YXRlXCIsXG4gICAgICAgIFwiL3Byb2MvbWFwcGluZ0tleXNcIixcbiAgICAgICAgXCIvaW5mby9hbGxvY2F0aW9ucy9zdG9yYWdlXCJcbiAgICAgIF0sXG5cbiAgICAgIChyZWZlcmVuY2VEZWNsYXJhdGlvbnMsIHN0YXRlLCBtYXBwaW5nS2V5cywgc3RvcmFnZUFsbG9jYXRpb25zKSA9PiAoXG4gICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgIHJlZlxuICAgICAgKSA9PlxuICAgICAgICBmb3JFdm1TdGF0ZShkZWZpbml0aW9uLCByZWYsIHtcbiAgICAgICAgICByZWZlcmVuY2VEZWNsYXJhdGlvbnMsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbWFwcGluZ0tleXMsXG4gICAgICAgICAgc3RvcmFnZUFsbG9jYXRpb25zXG4gICAgICAgIH0pXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczoge1xuICAgICAgLypcbiAgICAgICAqIGRhdGEudmlld3MudXNlckRlZmluZWRUeXBlcy5jb250cmFjdERlZmluaXRpb25zXG4gICAgICAgKiByZXN0cmljdCB0byBjb250cmFjdHMgb25seSwgYW5kIGdldCB0aGVpciBkZWZpbml0aW9uc1xuICAgICAgICovXG4gICAgICBjb250cmFjdERlZmluaXRpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvaW5mby91c2VyRGVmaW5lZFR5cGVzXCIsIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCJdLFxuICAgICAgICAodHlwZUlkcywgc2NvcGVzKSA9PlxuICAgICAgICAgIHR5cGVJZHNcbiAgICAgICAgICAgIC5tYXAoaWQgPT4gc2NvcGVzW2lkXS5kZWZpbml0aW9uKVxuICAgICAgICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IFwiQ29udHJhY3REZWZpbml0aW9uXCIpXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnNcbiAgICAgKi9cbiAgICByZWZlcmVuY2VEZWNsYXJhdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3Njb3Blcy9pbmxpbmVkXCIsIFwiL2luZm8vdXNlckRlZmluZWRUeXBlc1wiXSxcbiAgICAgIChzY29wZXMsIHVzZXJEZWZpbmVkVHlwZXMpID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4udXNlckRlZmluZWRUeXBlcy5tYXAoaWQgPT4gKHsgW2lkXTogc2NvcGVzW2lkXS5kZWZpbml0aW9uIH0pKVxuICAgICAgICApXG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBkYXRhLmluZm8uc2NvcGVzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgc2NvcGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuaW5mby5zY29wZXMgKHNlbGVjdG9yKVxuICAgICAgICogdGhlIHJhdyB2ZXJzaW9uIGlzIGJlbG93OyB0aGlzIHZlcnNpb24gYWNjb3VudHMgZm9yIGluaGVyaXRhbmNlXG4gICAgICAgKiBOT1RFOiBkb2Vzbid0IHRoaXMgc2VsZWN0b3IgcmVhbGx5IGJlbG9uZyBpbiBkYXRhLnZpZXdzPyAgWWVzLlxuICAgICAgICogQnV0LCBzaW5jZSBpdCdzIHJlcGxhY2luZyB0aGUgb2xkIGRhdGEuaW5mby5zY29wZXMgKHdoaWNoIGlzIG5vd1xuICAgICAgICogZGF0YS5pbmZvLnNjb3Blcy5yYXcpLCBJIGRpZG4ndCB3YW50IHRvIG1vdmUgaXQuXG4gICAgICAgKi9cbiAgICAgIF86IGNyZWF0ZUxlYWYoW1wiLi9yYXdcIiwgXCIvdmlld3Mvc2NvcGVzL2lubGluZWQvcmF3XCJdLCAoc2NvcGVzLCBpbmxpbmVkKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHNjb3BlcykubWFwKChbaWQsIHNjb3BlXSkgPT4ge1xuICAgICAgICAgICAgbGV0IGRlZmluaXRpb24gPSBpbmxpbmVkW2lkXS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBkZWZpbml0aW9uLm5vZGVUeXBlICE9PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiIHx8XG4gICAgICAgICAgICAgIHNjb3BlLnZhcmlhYmxlcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogc2NvcGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgd2UndmUgcmVhY2hlZCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgYmUgZGVhbGluZyB3aXRoIGFcbiAgICAgICAgICAgIC8vY29udHJhY3QsIGFuZCBzcGVjaWZpY2FsbHkgYSBjb250cmFjdCAtLSBub3QgYW4gaW50ZXJmYWNlIG9yXG4gICAgICAgICAgICAvL2xpYnJhcnkgKHRob3NlIGRvbid0IGdldCBcInZhcmlhYmxlc1wiIGVudHJpZXMgaW4gdGhlaXIgc2NvcGVzKVxuICAgICAgICAgICAgZGVidWcoXCJjb250cmFjdCBpZCAlZFwiLCBpZCk7XG4gICAgICAgICAgICBsZXQgbmV3U2NvcGUgPSB7IC4uLnNjb3BlIH07XG4gICAgICAgICAgICAvL25vdGUgdGhhdCBTb2xpZGl0eSBnaXZlcyB1cyB0aGUgbGluZWFyaXphdGlvbiBpbiBvcmRlciBmcm9tIG1vc3RcbiAgICAgICAgICAgIC8vZGVyaXZlZCB0byBtb3N0IGJhc2UsIGJ1dCB3ZSB3YW50IG1vc3QgYmFzZSB0byBtb3N0IGRlcml2ZWQ7XG4gICAgICAgICAgICAvL2Fubm95aW5nbHksIHJldmVyc2UoKSBpcyBpbi1wbGFjZSwgc28gd2UgY2xvbmUgd2l0aCBzbGljZSgpIGZpcnN0XG4gICAgICAgICAgICBsZXQgbGluZWFyaXplZEJhc2VDb250cmFjdHNGcm9tQmFzZSA9IGRlZmluaXRpb24ubGluZWFyaXplZEJhc2VDb250cmFjdHNcbiAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICAgICAgICAgIC8vbm93LCB3ZSBwdXQgaXQgYWxsIHRvZ2V0aGVyXG4gICAgICAgICAgICBuZXdTY29wZS52YXJpYWJsZXMgPSBbXVxuICAgICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICAgIC4uLmxpbmVhcml6ZWRCYXNlQ29udHJhY3RzRnJvbUJhc2UubWFwKFxuICAgICAgICAgICAgICAgICAgY29udHJhY3RJZCA9PiBzY29wZXNbY29udHJhY3RJZF0udmFyaWFibGVzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5maWx0ZXIodmFyaWFibGUgPT4ge1xuICAgICAgICAgICAgICAgIC8vLi4uZXhjZXB0LCBIQUNLLCBsZXQncyBmaWx0ZXIgb3V0IHRob3NlIGNvbnN0YW50cyB3ZSBkb24ndCBrbm93XG4gICAgICAgICAgICAgICAgLy9ob3cgdG8gcmVhZC4gIHRoZXknbGwganVzdCBjbHV0dGVyIHRoaW5ncyB1cC5cbiAgICAgICAgICAgICAgICBsZXQgZGVmaW5pdGlvbiA9IGlubGluZWRbdmFyaWFibGUuaWRdLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICFkZWZpbml0aW9uLmNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzU2ltcGxlQ29uc3RhbnQoZGVmaW5pdGlvbi52YWx1ZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogbmV3U2NvcGUgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuXG4gICAgICAvKlxuICAgICAgICogZGF0YS5pbmZvLnNjb3Blcy5yYXdcbiAgICAgICAqL1xuICAgICAgcmF3OiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5zY29wZXMuYnlJZClcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBkYXRhLmluZm8uYWxsb2NhdGlvbnNcbiAgICAgKi9cbiAgICBhbGxvY2F0aW9uczoge1xuICAgICAgLypcbiAgICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9ucy5zdG9yYWdlXG4gICAgICAgKi9cbiAgICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLmFsbG9jYXRpb25zLnN0b3JhZ2UpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuaW5mby51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9zdGF0ZVwiXSxcbiAgICAgIHN0YXRlID0+IHN0YXRlLmluZm8udXNlckRlZmluZWRUeXBlc1xuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5wcm9jXG4gICAqL1xuICBwcm9jOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICovXG4gICAgYXNzaWdubWVudHM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICAvL25vdGU6IHRoaXMgbm8gbG9uZ2VyIGZldGNoZXMganVzdCB0aGUgYnlJZCwgYnV0IHJhdGhlciB0aGUgd2hvbGVcbiAgICAgIC8vYXNzaWdubWVudHMgb2JqZWN0XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5tYXBwaW5nS2V5c1xuICAgICAqXG4gICAgICoga25vd24ga2V5cyBmb3IgZWFjaCBtYXBwaW5nIChpZGVudGlmaWVkIGJ5IG5vZGUgSUQpXG4gICAgICovXG4gICAgbWFwcGluZ0tleXM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLm1hcHBpbmdLZXlzLmJ5SWQpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmRlY29kaW5nTWFwcGluZ0tleXNcbiAgICAgKlxuICAgICAqIG51bWJlciBvZiBtYXBwaW5nIGtleXMgdGhhdCBhcmUgc3RpbGwgZGVjb2RpbmdcbiAgICAgKi9cbiAgICBkZWNvZGluZ01hcHBpbmdLZXlzOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL3N0YXRlXCJdLFxuICAgICAgc3RhdGUgPT4gc3RhdGUucHJvYy5tYXBwaW5nS2V5cy5kZWNvZGluZ1N0YXJ0ZWRcbiAgICApXG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogZGF0YS5jdXJyZW50LnNjb3BlXG4gICAgICovXG4gICAgc2NvcGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LnNjb3BlLmlkXG4gICAgICAgKi9cbiAgICAgIGlkOiBjcmVhdGVMZWFmKFthc3QuY3VycmVudC5ub2RlXSwgbm9kZSA9PiBub2RlLmlkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQuc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0ZTogY3JlYXRlU3RhdGVTZWxlY3RvcnMoZXZtLmN1cnJlbnQuc3RhdGUpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5hZGRyZXNzXG4gICAgICogTm90ZTogTWF5IGJlIHVuZGVmaW5lZCAoaWYgaW4gYW4gaW5pdGlhbGl6ZXIpXG4gICAgICovXG5cbiAgICBhZGRyZXNzOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jYWxsXSwgY2FsbCA9PiBjYWxsLmFkZHJlc3MpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmR1bW15QWRkcmVzc1xuICAgICAqL1xuXG4gICAgZHVtbXlBZGRyZXNzOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jcmVhdGlvbkRlcHRoXSwgaWRlbnRpdHkpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgaWRlbnRpZmllcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChzZWxlY3RvcilcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGlkZW50aWZlcnMgYW5kIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiBub2RlIElEXG4gICAgICAgKi9cbiAgICAgIF86IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBcIi9jdXJyZW50L3Njb3BlXCJdLFxuXG4gICAgICAgIChzY29wZXMsIHNjb3BlKSA9PiB7XG4gICAgICAgICAgbGV0IGN1ciA9IHNjb3BlLmlkO1xuICAgICAgICAgIGxldCB2YXJpYWJsZXMgPSB7fTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgLi4uKHNjb3Blc1tjdXJdLnZhcmlhYmxlcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdi5uYW1lICE9PSBcIlwiKSAvL2V4Y2x1ZGUgYW5vbnltb3VzIG91dHB1dCBwYXJhbXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdmFyaWFibGVzW3YubmFtZV0gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAodiA9PiAoeyBbdi5uYW1lXTogdi5pZCB9KSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGN1ciA9IHNjb3Blc1tjdXJdLnBhcmVudElkO1xuICAgICAgICAgIH0gd2hpbGUgKGN1ciAhPSBudWxsKTtcblxuICAgICAgICAgIHJldHVybiB2YXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zXG4gICAgICAgKlxuICAgICAgICogY3VycmVudCB2YXJpYWJsZSBkZWZpbml0aW9uc1xuICAgICAgICovXG4gICAgICBkZWZpbml0aW9uczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiLi9fXCJdLFxuXG4gICAgICAgIChzY29wZXMsIGlkZW50aWZpZXJzKSA9PlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGlkZW50aWZpZXJzKS5tYXAoKFtpZGVudGlmaWVyLCBpZF0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gc2NvcGVzW2lkXTtcblxuICAgICAgICAgICAgICByZXR1cm4geyBbaWRlbnRpZmllcl06IGRlZmluaXRpb24gfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGVzJyB2YWx1ZSByZWZzXG4gICAgICAgKi9cbiAgICAgIHJlZnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi9wcm9jL2Fzc2lnbm1lbnRzXCIsXG4gICAgICAgICAgXCIuL19cIixcbiAgICAgICAgICBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGgsIC8vZm9yIHBydW5pbmcgdGhpbmdzIHRvbyBkZWVwIG9uIHN0YWNrXG4gICAgICAgICAgXCIvY3VycmVudC9hZGRyZXNzXCIsIC8vZm9yIGNvbnRyYWN0IHZhcmlhYmxlc1xuICAgICAgICAgIFwiL2N1cnJlbnQvZHVtbXlBZGRyZXNzXCIgLy9mb3IgY29udHJhY3QgdmFycyB3aGVuIGluIGNyZWF0aW9uIGNhbGxcbiAgICAgICAgXSxcblxuICAgICAgICAoYXNzaWdubWVudHMsIGlkZW50aWZpZXJzLCBjdXJyZW50RGVwdGgsIGFkZHJlc3MsIGR1bW15QWRkcmVzcykgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKChbaWRlbnRpZmllciwgYXN0SWRdKSA9PiB7XG4gICAgICAgICAgICAgIC8vbm90ZTogdGhpcyBuZWVkcyB0d2Vha2luZyBmb3Igc3BlY2lhbHMgbGF0ZXJcbiAgICAgICAgICAgICAgbGV0IGlkO1xuXG4gICAgICAgICAgICAgIC8vZmlyc3QsIGNoZWNrIGlmIGl0J3MgYSBjb250cmFjdCB2YXJcbiAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaElkcyA9IChhc3NpZ25tZW50cy5ieUFzdElkW2FzdElkXSB8fCBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgaWRIYXNoID0+IGFzc2lnbm1lbnRzLmJ5SWRbaWRIYXNoXS5hZGRyZXNzID09PSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWQgPSBtYXRjaElkc1swXTsgLy90aGVyZSBzaG91bGQgb25seSBiZSBvbmUhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaElkcyA9IChhc3NpZ25tZW50cy5ieUFzdElkW2FzdElkXSB8fCBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgaWRIYXNoID0+XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLmJ5SWRbaWRIYXNoXS5kdW1teUFkZHJlc3MgPT09IGR1bW15QWRkcmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkID0gbWF0Y2hJZHNbMF07IC8vYWdhaW4sIHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL2lmIG5vdCBjb250cmFjdCwgaXQncyBsb2NhbCwgc28gZmluZCB0aGUgaW5uZXJtb3N0XG4gICAgICAgICAgICAgIC8vKGJ1dCBub3QgYmV5b25kIGN1cnJlbnQgZGVwdGgpXG4gICAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoRnJhbWVzID0gKGFzc2lnbm1lbnRzLmJ5QXN0SWRbYXN0SWRdIHx8IFtdKVxuICAgICAgICAgICAgICAgICAgLm1hcChpZCA9PiBhc3NpZ25tZW50cy5ieUlkW2lkXS5zdGFja2ZyYW1lKVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihzdGFja2ZyYW1lID0+IHN0YWNrZnJhbWUgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hGcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgLy90aGlzIGNoZWNrIGlzbid0ICpyZWFsbHkqXG4gICAgICAgICAgICAgICAgICAvL25lY2Vzc2FyeSwgYnV0IG1heSBhcyB3ZWxsIHByZXZlbnQgc3R1cGlkIHN0dWZmXG4gICAgICAgICAgICAgICAgICBsZXQgbWF4TWF0Y2ggPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5tYXRjaEZyYW1lcylcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZCA9IHN0YWJsZUtlY2NhazI1Nih7IGFzdElkLCBzdGFja2ZyYW1lOiBtYXhNYXRjaCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL2lmIHdlIHN0aWxsIGRpZG4ndCBmaW5kIGl0LCBvaCB3ZWxsXG5cbiAgICAgICAgICAgICAgbGV0IHsgcmVmIH0gPSBhc3NpZ25tZW50cy5ieUlkW2lkXSB8fCB7fTtcbiAgICAgICAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHJlZlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWNvZGVkXG4gICAgICAgKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgYXMgUHJvbWlzZXNcbiAgICAgICAqL1xuICAgICAgZGVjb2RlZDogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL2RlY29kZXJcIiwgXCIuL2RlZmluaXRpb25zXCIsIFwiLi9yZWZzXCJdLFxuXG4gICAgICAgIGFzeW5jIChkZWNvZGUsIGRlZmluaXRpb25zLCByZWZzKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ZWRQcm9taXNlcyA9IE9iamVjdC5lbnRyaWVzKHJlZnMpLm1hcChcbiAgICAgICAgICAgIGFzeW5jIChbaWRlbnRpZmllciwgcmVmXSkgPT4gKHtcbiAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBhd2FpdCBkZWNvZGUoZGVmaW5pdGlvbnNbaWRlbnRpZmllcl0sIHJlZilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBrZXllZFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXllZFByb21pc2VzKTtcbiAgICAgICAgICByZXR1cm4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi5jbGVhbkNvbnRhaW5lcnMoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCAuLi5rZXllZFJlc3VsdHMpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5uZXh0LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IGNyZWF0ZVN0YXRlU2VsZWN0b3JzKGV2bS5uZXh0LnN0YXRlKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGF0YTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqc29uLXBvaW50ZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIlxuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIlxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDptYXBcIik7XG5cbmltcG9ydCBJbnRlcnZhbFRyZWUgZnJvbSBcIm5vZGUtaW50ZXJ2YWwtdHJlZVwiO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlKG5vZGUpIHtcbiAgLy8gc3JjOiBcIjxzdGFydD46PGxlbmd0aD46PF8+XCJcbiAgLy8gcmV0dXJucyBbc3RhcnQsIGVuZF1cbiAgbGV0IFtzdGFydCwgbGVuZ3RoXSA9IG5vZGUuc3JjXG4gICAgLnNwbGl0KFwiOlwiKVxuICAgIC5zbGljZSgwLCAyKVxuICAgIC5tYXAoIChpKSA9PiBwYXJzZUludChpKSApO1xuXG4gIHJldHVybiBbc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VOb2Rlcyhub2RlLCBwb2ludGVyID0gXCJcIikge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgIC4uLm5vZGUubWFwKCAoc3ViLCBpKSA9PiByYW5nZU5vZGVzKHN1YiwgYCR7cG9pbnRlcn0vJHtpfWApIClcbiAgICApO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKG5vZGUuc3JjKSB7XG4gICAgICByZXN1bHRzLnB1c2goe3BvaW50ZXIsIHJhbmdlOiBnZXRSYW5nZShub2RlKX0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLmNvbmNhdChcbiAgICAgIC4uLk9iamVjdC5rZXlzKG5vZGUpLm1hcChcbiAgICAgICAgKGtleSkgPT4gcmFuZ2VOb2Rlcyhub2RlW2tleV0sIGAke3BvaW50ZXJ9LyR7a2V5fWApXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFJhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpIHtcbiAgbGV0IHJhbmdlcyA9IHJhbmdlTm9kZXMobm9kZSk7XG4gIGxldCB0cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xuXG4gIHJhbmdlcy5mb3JFYWNoKCAoe3JhbmdlLCBwb2ludGVyfSkgPT4ge1xuICAgIGxldCBbc3RhcnQsIGVuZF0gPSByYW5nZTtcblxuICAgIHRyZWUuaW5zZXJ0KHN0YXJ0LCBlbmQsIHtyYW5nZSwgcG9pbnRlcn0pO1xuICB9KTtcblxuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG5cbiAgbGV0IG92ZXJsYXBwaW5nID0gdHJlZS5zZWFyY2goc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG5cbiAgLy8gZmluZCBub2RlcyB0aGF0IGZ1bGx5IGNvbnRhaW4gcmVxdWVzdGVkIHJhbmdlLFxuICAvLyByZXR1cm4gbG9uZ2VzdCBwb2ludGVyXG4gIHJldHVybiBvdmVybGFwcGluZ1xuICAgIC5maWx0ZXIoICh7cmFuZ2V9KSA9PiBzb3VyY2VTdGFydCA+PSByYW5nZVswXSAmJiBzb3VyY2VFbmQgPD0gcmFuZ2VbMV0gKVxuICAgIC5tYXAoICh7cG9pbnRlcn0pID0+IHBvaW50ZXIgKVxuICAgIC5yZWR1Y2UoIChhLCBiKSA9PiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIsIFwiXCIgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvYXN0L21hcC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZGVjb2RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZGVjb2RlclwiXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLFxuICAgIHBvaW50ZXIsXG4gICAgcGFyZW50SWQsXG4gICAgc291cmNlSWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFQ0xBUkUgPSBcIkRFQ0xBUkVfVkFSSUFCTEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBERUNMQVJFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGFzc2lnbm1lbnRzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfS0VZID0gXCJNQVBfS0VZXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5KGlkLCBrZXkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBNQVBfS0VZLFxuICAgIGlkLFxuICAgIGtleVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTUFQX0tFWV9ERUNPRElORyA9IFwiTUFQX0tFWV9ERUNPRElOR1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEtleURlY29kaW5nKHN0YXJ0ZWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBNQVBfS0VZX0RFQ09ESU5HLFxuICAgIHN0YXJ0ZWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFU0VUID0gXCJEQVRBX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBMRUFSTl9BRERSRVNTID0gXCJMRUFSTl9BRERSRVNTXCI7XG5leHBvcnQgZnVuY3Rpb24gbGVhcm5BZGRyZXNzKGR1bW15QWRkcmVzcywgYWRkcmVzcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IExFQVJOX0FERFJFU1MsXG4gICAgZHVtbXlBZGRyZXNzLFxuICAgIGFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFRklORV9UWVBFID0gXCJERUZJTkVfVFlQRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVR5cGUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERFRklORV9UWVBFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFMTE9DQVRFID0gXCJBTExPQ0FURVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jYXRlKHN0b3JhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBTExPQ0FURSxcbiAgICBzdG9yYWdlXG4gICAgLy9sYXRlciB0aGVyZSB3aWxsIGJlIG1vcmVcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnRyYWNlOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyB0YWtlLCB0YWtlRXZlcnksIHB1dCwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwgaXNDYWxsTW5lbW9uaWMgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IHRyYWNlIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuZnVuY3Rpb24qIHdhaXRGb3JUcmFjZSgpIHtcbiAgbGV0IHsgc3RlcHMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TQVZFX1NURVBTKTtcblxuICBsZXQgYWRkcmVzc2VzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBzdGVwc1xuICAgICAgICAuZmlsdGVyKCh7IG9wIH0pID0+IGlzQ2FsbE1uZW1vbmljKG9wKSlcbiAgICAgICAgLm1hcCgoeyBzdGFjayB9KSA9PlxuICAgICAgICAgIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdKVxuICAgICAgICApXG4gICAgKVxuICBdO1xuXG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVBZGRyZXNzZXMoYWRkcmVzc2VzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYWR2YW5jZSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMubmV4dCgpKTtcblxuICBkZWJ1ZyhcIlRPQ0sgdG8gdGFrZVwiKTtcbiAgeWllbGQgdGFrZShbYWN0aW9ucy5UT0NLLCBhY3Rpb25zLkVORF9PRl9UUkFDRV0pO1xuICBkZWJ1ZyhcIlRPQ0sgdGFrZW5cIik7XG59XG5cbmZ1bmN0aW9uKiBuZXh0KCkge1xuICBsZXQgcmVtYWluaW5nID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzUmVtYWluaW5nKTtcbiAgZGVidWcoXCJyZW1haW5pbmc6ICVvXCIsIHJlbWFpbmluZyk7XG4gIGxldCBzdGVwcyA9IHlpZWxkIHNlbGVjdCh0cmFjZS5zdGVwcyk7XG4gIGRlYnVnKFwidG90YWwgc3RlcHM6ICVvXCIsIHN0ZXBzLmxlbmd0aCk7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgVElDS1wiKTtcbiAgICAvLyB1cGRhdGVzIHN0YXRlIGZvciBjdXJyZW50IHN0ZXBcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy50aWNrKCkpO1xuICAgIGRlYnVnKFwicHV0IFRJQ0tcIik7XG5cbiAgICByZW1haW5pbmctLTsgLy8gbG9jYWwgdXBkYXRlLCBqdXN0IGZvciBjb252ZW5pZW5jZVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZykge1xuICAgIGRlYnVnKFwicHV0dGluZyBUT0NLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RlcCB0byBuZXh0IHN0ZXAgaW4gdHJhY2VcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy50b2NrKCkpO1xuICAgIGRlYnVnKFwicHV0IFRPQ0tcIik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIEVORF9PRl9UUkFDRVwiKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5lbmRUcmFjZSgpKTtcbiAgICBkZWJ1ZyhcInB1dCBFTkRfT0ZfVFJBQ0VcIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBwcm9jZXNzVHJhY2UodHJhY2UpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0ZXBzKHRyYWNlKSk7XG5cbiAgbGV0IHsgYWRkcmVzc2VzIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9BRERSRVNTRVMpO1xuICBkZWJ1ZyhcInJlY2VpdmVkIGFkZHJlc3Nlc1wiKTtcblxuICByZXR1cm4gYWRkcmVzc2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICAvLyB3YWl0IGZvciB0cmFjZSB0byBiZSBkZWZpbmVkXG4gIHlpZWxkKiB3YWl0Rm9yVHJhY2UoKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5ORVhULCBuZXh0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInRyYWNlXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG4vKipcbiAqIEFkZHMgRVZNIGJ5dGVjb2RlIGNvbnRleHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZENvbnRleHQoY29udHJhY3ROYW1lLCB7IGFkZHJlc3MsIGJpbmFyeSB9LCBjb21waWxlcikge1xuICBjb25zdCByYXcgPSBiaW5hcnkgfHwgYWRkcmVzcztcbiAgY29uc3QgY29udGV4dCA9IGtlY2NhazI1NihyYXcpO1xuXG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZENvbnRleHQoY29udHJhY3ROYW1lLCByYXcsIGNvbXBpbGVyKSk7XG5cbiAgaWYgKGJpbmFyeSkge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmFkZEJpbmFyeShjb250ZXh0LCBiaW5hcnkpKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIEFkZHMga25vd24gZGVwbG95ZWQgaW5zdGFuY2Ugb2YgYmluYXJ5IGF0IGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5IC0gbWF5IGJlIHVuZGVmaW5lZCAoZS5nLiBwcmVjb21waWxlcylcbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgKDB4LXByZWZpeGVkIGtlY2NhayBvZiBiaW5hcnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogYWRkSW5zdGFuY2UoYWRkcmVzcywgYmluYXJ5KSB7XG4gIGxldCBzZWFyY2ggPSB5aWVsZCBzZWxlY3QoZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoKTtcbiAgbGV0IHsgY29udGV4dCB9ID0gc2VhcmNoKGJpbmFyeSk7XG5cbiAgLy8gaW4gY2FzZSBiaW5hcnkgaXMgdW5rbm93biwgYWRkIGNvbnRleHQgZm9yIGFkZHJlc3NcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IHlpZWxkKiBhZGRDb250ZXh0KHVuZGVmaW5lZCwgeyBhZGRyZXNzIH0sIHVuZGVmaW5lZCk7XG4gIH1cblxuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRJbnN0YW5jZShhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkpKTtcblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBiZWdpbih7IGFkZHJlc3MsIGJpbmFyeSB9KSB7XG4gIGlmIChhZGRyZXNzKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuY2FsbChhZGRyZXNzKSk7XG4gIH0gZWxzZSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuY3JlYXRlKGJpbmFyeSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogY2FsbHN0YWNrU2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB5aWVsZCB0YWtlKFRJQ0spO1xuXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzQ2FsbCkpIHtcbiAgICAgIGRlYnVnKFwiZ290IGNhbGxcIik7XG4gICAgICBsZXQgYWRkcmVzcyA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxBZGRyZXNzKTtcblxuICAgICAgZGVidWcoXCJjYWxsaW5nIGFkZHJlc3MgJXNcIiwgYWRkcmVzcyk7XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJpbmFyeSAoZS5nLiBpbiB0aGUgY2FzZSBvZiBwcmVjb21waWxlZCBjb250cmFjdHMpLFxuICAgICAgLy8gdGhlbiB0aGVyZSB3aWxsIGJlIG5vIHRyYWNlIHN0ZXBzIGZvciB0aGUgY2FsbGVkIGNvZGUsIGFuZCBzbyB3ZVxuICAgICAgLy8gc2hvdWxkbid0IHRlbGwgdGhlIGRlYnVnZ2VyIHRoYXQgd2UncmUgZW50ZXJpbmcgYW5vdGhlciBleGVjdXRpb25cbiAgICAgIC8vIGNvbnRleHRcbiAgICAgIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jYWxsc1ByZWNvbXBpbGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcbiAgICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzQ3JlYXRlKSkge1xuICAgICAgZGVidWcoXCJnb3QgY3JlYXRlXCIpO1xuICAgICAgbGV0IGJpbmFyeSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZUJpbmFyeSk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnkpKTtcbiAgICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZykpIHtcbiAgICAgIGRlYnVnKFwiZ290IHJldHVyblwiKTtcblxuICAgICAgbGV0IGNhbGxzdGFjayA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsc3RhY2spO1xuXG4gICAgICAvL2lmIHRoZSBwcm9ncmFtJ3Mgbm90IGVuZGluZywgYW5kIHdlIGp1c3QgcmV0dXJuZWQgZnJvbSBhIGNvbnN0cnVjdG9yLFxuICAgICAgLy9sZWFybiB0aGUgYWRkcmVzcyBvZiB3aGF0IHdlIGp1c3QgaW5pdGlhbGl6ZWRcbiAgICAgIC8vKGRvIHRoaXMgYmVmb3JlIHdlIHB1dCB0aGUgcmV0dXJuIGFjdGlvbiB0byBhdm9pZCBvZmYtYnktb25lIGVycm9yKVxuICAgICAgaWYgKFxuICAgICAgICBjYWxsc3RhY2subGVuZ3RoID4gMSAmJlxuICAgICAgICBjYWxsc3RhY2tbY2FsbHN0YWNrLmxlbmd0aCAtIDFdLmFkZHJlc3MgPT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGxldCBkdW1teUFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY3JlYXRpb25EZXB0aCk7XG4gICAgICAgIGRlYnVnKFwiZHVtbXlBZGRyZXNzICVkXCIsIGR1bW15QWRkcmVzcyk7XG5cbiAgICAgICAgLy9OT1RFOiB0aGUgZm9sbG93aW5nIGxvZ2ljLCBmb3IgZ2V0dGluZyB0aGUgY3JlYXRlZCBhZGRyZXNzLCByZWFsbHlcbiAgICAgICAgLy9iZWxvbmdzIGluIGEgc2VsZWN0b3IuICBIb3dldmVyLCBldmVyeSB0aW1lIEkgdHJ5IHRvIG1ha2UgaXQgYVxuICAgICAgICAvL3NlbGVjdG9yLCBJIGdldCBteXN0ZXJpb3VzIGVycm9yIG1lc3NhZ2VzLiAgU28sIHdlJ2xsIGRvIGl0IG91cnNlbHZlc1xuICAgICAgICAvL2luIHRoZSBzYWdhIGluc3RlYWQuXG5cbiAgICAgICAgbGV0IHN0YWNrID0geWllbGQgc2VsZWN0KGV2bS5uZXh0LnN0YXRlLnN0YWNrKTtcbiAgICAgICAgbGV0IGNyZWF0ZWRBZGRyZXNzID0gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0FkZHJlc3MoXG4gICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgKTtcbiAgICAgICAgZGVidWcoXCJjcmVhdGVkQWRkcmVzcyAlc1wiLCBjcmVhdGVkQWRkcmVzcyk7XG5cbiAgICAgICAgeWllbGQqIGRhdGEubGVhcm5BZGRyZXNzU2FnYShkdW1teUFkZHJlc3MsIGNyZWF0ZWRBZGRyZXNzKTtcbiAgICAgICAgZGVidWcoXCJhZGRyZXNzIGxlYXJudFwiKTtcbiAgICAgIH1cblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMucmV0dXJuQ2FsbCgpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgY2FsbChjYWxsc3RhY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImV2bVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NhZ2FzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IEFERF9DT05URVhUID0gXCJFVk1fQUREX0NPTlRFWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgcmF3LCBjb21waWxlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9DT05URVhULFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICByYXcsXG4gICAgY29tcGlsZXJcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFERF9CSU5BUlkgPSBcIkVWTV9BRERfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQmluYXJ5KGNvbnRleHQsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9CSU5BUlksXG4gICAgY29udGV4dCxcbiAgICBiaW5hcnlcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFERF9JTlNUQU5DRSA9IFwiRVZNX0FERF9JTlNUQU5DRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEluc3RhbmNlKGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9JTlNUQU5DRSxcbiAgICBhZGRyZXNzLFxuICAgIGNvbnRleHQsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0FMTCxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDUkVBVEUgPSBcIkNSRUFURVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDUkVBVEUsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk4gPSBcIlJFVFVSTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkNhbGwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVUVVJOXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiRVZNX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYWxsLCBwdXQsIHRha2UsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24qIGFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBhZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkU291cmNlTWFwKGJpbmFyeSwgc291cmNlTWFwKSk7XG59XG5cbmZ1bmN0aW9uKiB0aWNrU2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB5aWVsZCB0YWtlKFRJQ0spO1xuICAgIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgICB5aWVsZCogZnVuY3Rpb25EZXB0aFNhZ2EoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiogZnVuY3Rpb25EZXB0aFNhZ2EoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICBsZXQganVtcERpcmVjdGlvbiA9IHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50Lmp1bXBEaXJlY3Rpb24pO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmp1bXAoanVtcERpcmVjdGlvbikpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxDYWxsKSkge1xuICAgIC8vd2UgaGF2ZSBzZXZlcmFsIGNhc2VzIGhlcmU6XG4gICAgLy8xLiBwcmVjb21waWxlIC0tICpkb24ndCogcHV0IGFueSBqdW1wXG4gICAgLy8yLiB3b3JrYXJvdW5kIGNhc2UgLS0gcHV0IGEgZG91YmxlIGp1bXAgKHNlZSBiZWxvdylcbiAgICAvLzMuIGdlbmVyYWwgY2FzZSAtLSBwdXQgYSBzaW5nbGUganVtcCBhcyBleHBlY3RlZFxuXG4gICAgZGVidWcoXCJhYm91dCB0byBjYWxsXCIpO1xuICAgIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC5jYWxsc1ByZWNvbXBpbGUpKSB7XG4gICAgICAvL2NhbGwgdG8gcHJlY29tcGlsZTsgZG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQubmVlZHNGdW5jdGlvbkRlcHRoV29ya2Fyb3VuZCkpICYmXG4gICAgICAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuaXNDb250cmFjdENhbGwpKVxuICAgICkge1xuICAgICAgLy9hbGwgdGhlc2UgcGFyZW50aGVzZXMgYXJlIG5lY2Vzc2FyeVxuICAgICAgLy9IQUNLIFdPUktBUk9VTkRcbiAgICAgIC8vYmVjYXVzZSBvZiB0aGUgcHJvYmxlbSBpbiBzb2xjIDwwLjUuMSB3aGVyZSBjb250cmFjdCBtZXRob2QgY2FsbHNcbiAgICAgIC8vZXNzZW50aWFsbHkgcmV0dXJuIHR3aWNlLCB3ZSBjb21wZW5zYXRlIGJ5IHB1dHRpbmcgKnR3byogaW53YXJkIGp1bXBzXG4gICAgICAvL2ZvciBzdWNoIGEgY2FsbC5cbiAgICAgIC8vTm90ZSB0aGF0IHRoaXMgd29uJ3Qgd29yayBpZiB0aGUgY29udHJhY3QgbWV0aG9kIHdhcyBwcmV2aW91c2x5IHBsYWNlZFxuICAgICAgLy9pbiBhIGZ1bmN0aW9uIHZhcmlhYmxlISAgVGhvc2Ugd2lsbCBjb250aW51ZSB0byBzY3JldyB0aGluZ3MgdXAhICBCdXRcbiAgICAgIC8vaWYgYSBjb250cmFjdCBjYWxsIGlzIGJlaW5nIG1hZGUgZGlyZWN0bHksIHdlIGNhbiBkZXRlY3QgdGhhdC5cbiAgICAgIC8vT2YgY291cnNlLCBhbGwgb2YgdGhpcyBzaG91bGQgd29yayBmaW5lIGFzIG9mIHNvbGlkaXR5IDAuNS4xLCB3aXRoIG5vXG4gICAgICAvL3dvcmthcm91bmQgbmVjZXNzYXJ5OyB0aGlzIGJyYW5jaCBzaG91bGQgb25seSBnZXQgdGFrZSBvbiBvbGRcbiAgICAgIC8vY29udHJhY3RzLlxuICAgICAgZGVidWcoXCJ3b3JrYXJvdW5kIGludm9rZWQhXCIpO1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChcIjJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL2FuIG9yZGluYXJ5IGNhbGwsIG5vdCB0byBhIHByZWNvbXBpbGUgJiB3aXRoIG5vIHdvcmthcm91bmQgbmVlZGVkXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKFwiaVwiKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxDcmVhdGUpKSB7XG4gICAgLy90aGlzIGNhc2UsIHRoYW5rZnVsbHksIG5lZWRzIG5vIGZ1cnRoZXIgYnJlYWtkb3duXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChcImlcIikpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxSZXR1cm4pKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChcIm9cIikpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHlpZWxkIGNhbGwodGlja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic29saWRpdHlcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IEFERF9TT1VSQ0UgPSBcIlNPTElESVRZX0FERF9TT1VSQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfU09VUkNFLFxuICAgIHNvdXJjZSxcbiAgICBzb3VyY2VQYXRoLFxuICAgIGFzdFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX1NPVVJDRU1BUCA9IFwiU09MSURJVFlfQUREX1NPVVJDRU1BUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0VNQVAsXG4gICAgYmluYXJ5LFxuICAgIHNvdXJjZU1hcFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSlVNUCA9IFwiSlVNUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGp1bXAoanVtcERpcmVjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEpVTVAsXG4gICAganVtcERpcmVjdGlvblxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlNPTElESVRZX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcblxuICAvKipcbiAgICogY29udHJvbGxlci5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6ICgoc3RhdGUpID0+IHN0YXRlLmNvbnRyb2xsZXIpLFxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVxuICAgICAgICovXG4gICAgICBzb3VyY2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgaWRlbnRpdHkpLFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5ub2RlXG4gICAgICAgKi9cbiAgICAgIG5vZGU6IGNyZWF0ZUxlYWYoW2FzdC5jdXJyZW50Lm5vZGVdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lXG4gICAgICAgKi9cbiAgICAgIGlzTXVsdGlsaW5lOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXSwgaWRlbnRpdHkpLFxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY29udHJvbGxlci5icmVha3BvaW50c1xuICAgKi9cbiAgYnJlYWtwb2ludHM6IGNyZWF0ZUxlYWYoW1wiLi9zdGF0ZVwiXSwgKHN0YXRlKSA9PiBzdGF0ZS5icmVha3BvaW50cyksXG5cbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuZmluaXNoZWRcbiAgICovXG4gIGZpbmlzaGVkOiBjcmVhdGVMZWFmKFt0cmFjZS5maW5pc2hlZF0sIGlkZW50aXR5KSxcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRyb2xsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvc2VsZWN0b3JzL2luZGV4LmpzIiwidmFyIERlYnVnZ2VyID0gcmVxdWlyZShcIi4vbGliL2RlYnVnZ2VyXCIpLmRlZmF1bHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVidWdnZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGVidWdnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZXhwZWN0IGZyb20gXCJ0cnVmZmxlLWV4cGVjdFwiO1xuXG5pbXBvcnQgU2Vzc2lvbiBmcm9tIFwiLi9zZXNzaW9uXCI7XG5cbmltcG9ydCB7IGNyZWF0ZU5lc3RlZFNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGRhdGFTZWxlY3RvciBmcm9tIFwiLi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdFNlbGVjdG9yIGZyb20gXCIuL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZVNlbGVjdG9yIGZyb20gXCIuL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bVNlbGVjdG9yIGZyb20gXCIuL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eVNlbGVjdG9yIGZyb20gXCIuL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNlc3Npb25TZWxlY3RvciBmcm9tIFwiLi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGNvbnRyb2xsZXJTZWxlY3RvciBmcm9tIFwiLi9jb250cm9sbGVyL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXJcIik7XG5cbi8qKlxuICogQGV4YW1wbGVcbiAqIGxldCBzZXNzaW9uID0gRGVidWdnZXJcbiAqICAgLmZvclR4KDx0eEhhc2g+LCB7XG4gKiAgICAgY29udHJhY3RzOiBbPGNvbnRyYWN0IG9iaj4sIC4uLl0sXG4gKiAgICAgcHJvdmlkZXI6IDxwcm92aWRlciBpbnN0YW5jZT5cbiAqICAgfSlcbiAqICAgLmNvbm5lY3QoKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWdnZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIC0gZGVidWdnZXIgc2Vzc2lvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2Vzc2lvbikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEgRGVidWdnZXIgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb24gaGFzaC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4SGFzaCAtIHRyYW5zYWN0aW9uIGhhc2ggd2l0aCBsZWFkaW5nIFwiMHhcIlxuICAgKiBAcGFyYW0ge3tjb250cmFjdHM6IEFycmF5PENvbnRyYWN0PiwgZmlsZXM6IEFycmF5PFN0cmluZz4sIHByb3ZpZGVyOiBXZWIzUHJvdmlkZXJ9fSBvcHRpb25zIC1cbiAgICogQHJldHVybiB7RGVidWdnZXJ9IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZm9yVHgodHhIYXNoLCBvcHRpb25zID0ge30pIHtcbiAgICBleHBlY3Qub3B0aW9ucyhvcHRpb25zLCBbXG4gICAgICBcImNvbnRyYWN0c1wiLFxuICAgICAgXCJwcm92aWRlclwiXG4gICAgXSk7XG5cbiAgICBsZXQgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKFxuICAgICAgb3B0aW9ucy5jb250cmFjdHMsIG9wdGlvbnMuZmlsZXMsXG4gICAgICB0eEhhc2gsIG9wdGlvbnMucHJvdmlkZXJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGhpcyhzZXNzaW9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBpbnN0YW50aWF0ZWQgRGVidWdnZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Nlc3Npb259IHNlc3Npb24gaW5zdGFuY2VcbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0ZWQgc2VsZWN0b3JzXG4gICAqXG4gICAqIFNlZSBpbmRpdmlkdWFsIHNlbGVjdG9yIGRvY3MgZm9yIGZ1bGwgbGlzdGluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMuYXN0LmN1cnJlbnQudHJlZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMuc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMudHJhY2Uuc3RlcHNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBjcmVhdGVOZXN0ZWRTZWxlY3Rvcih7XG4gICAgICBhc3Q6IGFzdFNlbGVjdG9yLFxuICAgICAgZGF0YTogZGF0YVNlbGVjdG9yLFxuICAgICAgdHJhY2U6IHRyYWNlU2VsZWN0b3IsXG4gICAgICBldm06IGV2bVNlbGVjdG9yLFxuICAgICAgc29saWRpdHk6IHNvbGlkaXR5U2VsZWN0b3IsXG4gICAgICBzZXNzaW9uOiBzZXNzaW9uU2VsZWN0b3IsXG4gICAgICBjb250cm9sbGVyOiBjb250cm9sbGVyU2VsZWN0b3IsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250cmFjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBjb250cmFjdCBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIHNvbGlkaXR5IHNvdXJjZSBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlUGF0aCBwYXRoIHRvIHNvdXJjZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmluYXJ5IDB4LXByZWZpeGVkIGhleCBzdHJpbmcgd2l0aCBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3IgY3JlYXRlIGJ5dGVjb2RlXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXN0IEFic3RyYWN0IFN5bnRheCBUcmVlIGZyb20gU29saWRpdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXBsb3llZEJpbmFyeSAweC1wcmVmaXhlZCBjb21waWxlZCBiaW5hcnkgKG9uIGNoYWluKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkU291cmNlTWFwIHNvbGlkaXR5IHNvdXJjZSBtYXAgZm9yIG9uLWNoYWluIGJ5dGVjb2RlXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGVidWdnZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWV4cGVjdFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZXhwZWN0XCJcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uXCIpOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCJsaWIvc3RvcmVcIjtcblxuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgZGF0YSBmcm9tIFwibGliL2RhdGEvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCByb290U2FnYSBmcm9tIFwiLi9zYWdhc1wiO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSBcIi4vcmVkdWNlcnNcIjtcblxuLyoqXG4gKiBEZWJ1Z2dlciBTZXNzaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxDb250cmFjdD59IGNvbnRyYWN0cyAtIGNvbnRyYWN0IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZmlsZXMgLSBhcnJheSBvZiBmaWxlbmFtZXMgZm9yIHNvdXJjZU1hcCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwYXJhbSB7V2ViM1Byb3ZpZGVyfSBwcm92aWRlciAtIHdlYjMgcHJvdmlkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlc3Npb24uc3RhdHVzID09IFwiQUNUSVZFXCIpIHtcbiAgICAgICAgICBhY2NlcHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS5zZXNzaW9uLnN0YXR1cyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuc3RhdGUuc2Vzc2lvbi5zdGF0dXMuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB1cCBhcnRpZmFjdHMgaW50byBcImNvbnRleHRzXCIgYW5kIFwic291cmNlc1wiLCBkaXZpZGluZyBhcnRpZmFjdFxuICAgKiBkYXRhIGludG8gYXBwcm9wcmlhdGUgYnVja2V0cy5cbiAgICpcbiAgICogTXVsdGlwbGUgY29udHJhY3RzIGNhbiBiZSBkZWZpbmVkIGluIHRoZSBzYW1lIHNvdXJjZSBmaWxlLCBidXQgaGF2ZVxuICAgKiBkaWZmZXJlbnQgYnl0ZWNvZGVzLlxuICAgKlxuICAgKiBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGNvbnRyYWN0cyBhbmQgY29sbGVjdHMgYmluYXJpZXMgc2VwYXJhdGVseVxuICAgKiBmcm9tIHNvdXJjZXMsIHVzaW5nIHRoZSBvcHRpb25hbCBgZmlsZXNgIGFyZ3VtZW50IHRvIGZvcmNlXG4gICAqIHNvdXJjZSBvcmRlcmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemUoY29udHJhY3RzLCBmaWxlcyA9IG51bGwpIHtcbiAgICBsZXQgc291cmNlc0J5UGF0aCA9IHt9O1xuICAgIGxldCBjb250ZXh0cyA9IFtdO1xuICAgIGxldCBzb3VyY2VzO1xuXG4gICAgZm9yIChsZXQgY29udHJhY3Qgb2YgY29udHJhY3RzKSB7XG4gICAgICBsZXQge1xuICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgIGJpbmFyeSxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBkZXBsb3llZEJpbmFyeSxcbiAgICAgICAgZGVwbG95ZWRTb3VyY2VNYXAsXG4gICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgYXN0LFxuICAgICAgICBjb21waWxlclxuICAgICAgfSA9IGNvbnRyYWN0O1xuXG4gICAgICBkZWJ1ZyhcInNvdXJjZU1hcCAlb1wiLCBzb3VyY2VNYXApO1xuICAgICAgZGVidWcoXCJjb21waWxlciAlb1wiLCBjb21waWxlcik7XG5cbiAgICAgIHNvdXJjZXNCeVBhdGhbc291cmNlUGF0aF0gPSB7IHNvdXJjZVBhdGgsIHNvdXJjZSwgYXN0IH07XG5cbiAgICAgIGlmIChiaW5hcnkgJiYgYmluYXJ5ICE9IFwiMHhcIikge1xuICAgICAgICBjb250ZXh0cy5wdXNoKHtcbiAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlcGxveWVkQmluYXJ5ICYmIGRlcGxveWVkQmluYXJ5ICE9IFwiMHhcIikge1xuICAgICAgICBjb250ZXh0cy5wdXNoKHtcbiAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgYmluYXJ5OiBkZXBsb3llZEJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXA6IGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICAgIGNvbXBpbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZmlsZXMpIHtcbiAgICAgIHNvdXJjZXMgPSBPYmplY3QudmFsdWVzKHNvdXJjZXNCeVBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VzID0gZmlsZXMubWFwKGZpbGUgPT4gc291cmNlc0J5UGF0aFtmaWxlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGV4dHMsIHNvdXJjZXMgfTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIHZpZXcoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IodGhpcy5zdGF0ZSk7XG4gIH1cblxuICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5pbnRlcnJ1cHQoKSk7XG4gIH1cblxuICBhZHZhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWR2YW5jZSgpKTtcbiAgfVxuXG4gIHN0ZXBOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuc3RlcE5leHQoKSk7XG4gIH1cblxuICBzdGVwT3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwSW50bygpKTtcbiAgfVxuXG4gIHN0ZXBPdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwT3V0KCkpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5yZXNldCgpKTtcbiAgfVxuXG4gIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuY29udGludWVVbnRpbEJyZWFrcG9pbnQoKSk7XG4gIH1cblxuICBhZGRCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLmFkZEJyZWFrcG9pbnQoYnJlYWtwb2ludCkpO1xuICB9XG5cbiAgcmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5yZW1vdmVCcmVha3BvaW50KGJyZWFrcG9pbnQpKTtcbiAgfVxuXG4gIHJlbW92ZUFsbEJyZWFrcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIucmVtb3ZlQWxsQnJlYWtwb2ludHMoKSk7XG4gIH1cblxuICBhc3luYyBkZWNvZGVSZWFkeSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgaGF2ZVJlc29sdmVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkRlY29kaW5nU3RhcnRlZCA9IHRoaXMudmlldyhcbiAgICAgICAgICBkYXRhLnByb2MuZGVjb2RpbmdNYXBwaW5nS2V5c1xuICAgICAgICApO1xuXG4gICAgICAgIGRlYnVnKFwiZm9sbG93aW5nIGRlY29kaW5nIHN0YXJ0ZWQ6ICVkXCIsIHN1YnNjcmlwdGlvbkRlY29kaW5nU3RhcnRlZCk7XG5cbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkRlY29kaW5nU3RhcnRlZCA8PSAwICYmICFoYXZlUmVzb2x2ZWQpIHtcbiAgICAgICAgICBoYXZlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGVjb2RpbmdTdGFydGVkID0gdGhpcy52aWV3KGRhdGEucHJvYy5kZWNvZGluZ01hcHBpbmdLZXlzKTtcblxuICAgICAgZGVidWcoXCJpbml0aWFsIGRlY29kaW5nIHN0YXJ0ZWQ6ICVkXCIsIGRlY29kaW5nU3RhcnRlZCk7XG5cbiAgICAgIGlmIChkZWNvZGluZ1N0YXJ0ZWQgPD0gMCkge1xuICAgICAgICBoYXZlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB2YXJpYWJsZShuYW1lKSB7XG4gICAgYXdhaXQgdGhpcy5kZWNvZGVSZWFkeSgpO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zKTtcbiAgICBjb25zdCByZWZzID0gdGhpcy52aWV3KGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5yZWZzKTtcblxuICAgIGNvbnN0IGRlY29kZSA9IHRoaXMudmlldyhkYXRhLnZpZXdzLmRlY29kZXIpO1xuICAgIHJldHVybiBhd2FpdCBkZWNvZGUoZGVmaW5pdGlvbnNbbmFtZV0sIHJlZnNbbmFtZV0pO1xuICB9XG5cbiAgYXN5bmMgdmFyaWFibGVzKCkge1xuICAgIGF3YWl0IHRoaXMuZGVjb2RlUmVhZHkoKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlY29kZWQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vaW5kZXguanMiLCJpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcHJvZHVjdGlvblwiKTtcbn0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdGVzdFwiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vZGV2ZWxvcG1lbnRcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL2luZGV4LmpzIiwiaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCIuL2NvbW1vblwiO1xuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlU3RvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL3Byb2R1Y3Rpb24uanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c3RvcmU6Y29tbW9uXCIpO1xuY29uc3QgcmVkdXhEZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6cmVkdXhcIik7XG5cbmltcG9ydCB7IGNvbXBvc2UsIGNyZWF0ZVN0b3JlLCBhcHBseU1pZGRsZXdhcmUgfSBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCBjcmVhdGVTYWdhTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtc2FnYVwiO1xuaW1wb3J0IGNyZWF0ZUxvZ2dlciBmcm9tIFwicmVkdXgtY2xpLWxvZ2dlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gYWJicmV2aWF0ZVZhbHVlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9LCBkZXB0aCA9IDApIHtcbiAgb3B0aW9ucy5zdHJpbmdMaW1pdCA9IG9wdGlvbnMuc3RyaW5nTGltaXQgfHwgNjY7XG4gIG9wdGlvbnMuYXJyYXlMaW1pdCA9IG9wdGlvbnMuYXJyYXlMaW1pdCB8fCA4O1xuICBvcHRpb25zLnJlY3Vyc2VMaW1pdCA9IG9wdGlvbnMucmVjdXJzZUxpbWl0IHx8IDQ7XG5cbiAgaWYgKGRlcHRoID4gb3B0aW9ucy5yZWN1cnNlTGltaXQpIHtcbiAgICByZXR1cm4gXCIuLi5cIjtcbiAgfVxuXG4gIGNvbnN0IHJlY3Vyc2UgPSAoY2hpbGQpID0+IGFiYnJldmlhdGVWYWx1ZXMoY2hpbGQsIG9wdGlvbnMsIGRlcHRoICsgMSk7XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG4gICAgICB2YWx1ZSA9IFtcbiAgICAgICAgLi4udmFsdWUuc2xpY2UoMCwgb3B0aW9ucy5hcnJheUxpbWl0IC8gMiksXG4gICAgICAgIFwiLi4uXCIsXG4gICAgICAgIC4uLnZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIG9wdGlvbnMuYXJyYXlMaW1pdCAvIDIgKyAxKVxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubWFwKHJlY3Vyc2UpO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoXG4gICAgICAgIChbaywgdl0pID0+ICh7IFtyZWN1cnNlKGspXTogcmVjdXJzZSh2KSB9KVxuICAgICAgKVxuICAgICk7XG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gb3B0aW9ucy5zdHJpbmdMaW1pdCkge1xuICAgIGxldCBpbm5lciA9IFwiLi4uXCI7XG4gICAgbGV0IGV4dHJhY3RBbW91bnQgPSAob3B0aW9ucy5zdHJpbmdMaW1pdCAtIGlubmVyLmxlbmd0aCkgLyAyO1xuICAgIGxldCBsZWFkaW5nID0gdmFsdWUuc2xpY2UoMCwgTWF0aC5jZWlsKGV4dHJhY3RBbW91bnQpKTtcbiAgICBsZXQgdHJhaWxpbmcgPSB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBNYXRoLmZsb29yKGV4dHJhY3RBbW91bnQpKTtcbiAgICByZXR1cm4gYCR7bGVhZGluZ30ke2lubmVyfSR7dHJhaWxpbmd9YDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25maWd1cmVTdG9yZSAocmVkdWNlciwgc2FnYSwgaW5pdGlhbFN0YXRlLCBjb21wb3NlRW5oYW5jZXJzKSB7XG4gIGNvbnN0IHNhZ2FNaWRkbGV3YXJlID0gY3JlYXRlU2FnYU1pZGRsZXdhcmUoKTtcblxuICBpZiAoIWNvbXBvc2VFbmhhbmNlcnMpIHtcbiAgICBjb21wb3NlRW5oYW5jZXJzID0gY29tcG9zZTtcbiAgfVxuXG4gIGNvbnN0IGxvZ2dlck1pZGRsZXdhcmUgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxvZzogcmVkdXhEZWJ1ZyxcbiAgICBzdGF0ZVRyYW5zZm9ybWVyOiAoc3RhdGUpID0+IGFiYnJldmlhdGVWYWx1ZXMoc3RhdGUsIHtcbiAgICAgIGFycmF5TGltaXQ6IDQsXG4gICAgICByZWN1cnNlTGltaXQ6IDNcbiAgICB9KSxcbiAgICBhY3Rpb25UcmFuc2Zvcm1lcjogYWJicmV2aWF0ZVZhbHVlcyxcbiAgfSk7XG5cbiAgbGV0IHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgcmVkdWNlciwgaW5pdGlhbFN0YXRlLFxuXG4gICAgY29tcG9zZUVuaGFuY2VycyhcbiAgICAgIGFwcGx5TWlkZGxld2FyZShcbiAgICAgICAgc2FnYU1pZGRsZXdhcmUsXG4gICAgICAgIGxvZ2dlck1pZGRsZXdhcmVcbiAgICAgIClcbiAgICApXG4gICk7XG5cbiAgc2FnYU1pZGRsZXdhcmUucnVuKHNhZ2EpO1xuXG4gIHJldHVybiBzdG9yZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvY29tbW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LXNhZ2FcIlxuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtY2xpLWxvZ2dlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIlxuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL3R5bGVyL3Byb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy90eWxlci9wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvdHlsZXIvcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIlxuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIEFuIGF1Z21lbnRlZCBBVkwgVHJlZSB3aGVyZSBlYWNoIG5vZGUgbWFpbnRhaW5zIGEgbGlzdCBvZiByZWNvcmRzIGFuZCB0aGVpciBzZWFyY2ggaW50ZXJ2YWxzLlxyXG4vLyBSZWNvcmQgaXMgY29tcG9zZWQgb2YgYW4gaW50ZXJ2YWwgYW5kIGl0cyB1bmRlcmx5aW5nIGRhdGEsIHNlbnQgYnkgYSBjbGllbnQuIFRoaXMgYWxsb3dzIHRoZVxyXG4vLyBpbnRlcnZhbCB0cmVlIHRvIGhhdmUgdGhlIHNhbWUgaW50ZXJ2YWwgaW5zZXJ0ZWQgbXVsdGlwbGUgdGltZXMsIGFzIGxvbmcgaXRzIGRhdGEgaXMgZGlmZmVyZW50LlxyXG4vLyBCb3RoIGluc2VydGlvbiBhbmQgZGVsZXRpb24gcmVxdWlyZSBPKGxvZyBuKSB0aW1lLiBTZWFyY2hpbmcgcmVxdWlyZXMgTyhrKmxvZ24pIHRpbWUsIHdoZXJlIGBrYFxyXG4vLyBpcyB0aGUgbnVtYmVyIG9mIGludGVydmFscyBpbiB0aGUgb3V0cHV0IGxpc3QuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGlzU2FtZSA9IHJlcXVpcmUoXCJzaGFsbG93ZXF1YWxcIik7XHJcbmZ1bmN0aW9uIGhlaWdodChub2RlKSB7XHJcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZShpbnRlcnZhbFRyZWUsIHJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlID0gaW50ZXJ2YWxUcmVlO1xyXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmtleSA9IHJlY29yZC5sb3c7XHJcbiAgICAgICAgdGhpcy5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAvLyBTYXZlIHRoZSBhcnJheSBvZiBhbGwgcmVjb3JkcyB3aXRoIHRoZSBzYW1lIGtleSBmb3IgdGhpcyBub2RlXHJcbiAgICAgICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgIH1cclxuICAgIC8vIEdldHMgdGhlIGhpZ2hlc3QgcmVjb3JkLmhpZ2ggdmFsdWUgZm9yIHRoaXMgbm9kZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZUhpZ2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLnJlY29yZHNbMF0uaGlnaDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvcmRzW2ldLmhpZ2ggPiBoaWdoKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gdGhpcy5yZWNvcmRzW2ldLmhpZ2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpZ2g7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBoZWlnaHQgdmFsdWUgb2YgdGhlIG5vZGUuIENhbGxlZCBkdXJpbmcgaW5zZXJ0aW9uLCByZWJhbGFuY2UsIHJlbW92YWxcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KGhlaWdodCh0aGlzLmxlZnQpLCBoZWlnaHQodGhpcy5yaWdodCkpICsgMTtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIHRoZSBtYXggdmFsdWUgb2YgYWxsIHRoZSBwYXJlbnRzIGFmdGVyIGluc2VydGluZyBpbnRvIGFscmVhZHkgZXhpc3Rpbmcgbm9kZSwgYXMgd2VsbCBhc1xyXG4gICAgLy8gcmVtb3ZpbmcgdGhlIG5vZGUgY29tcGxldGVseSBvciByZW1vdmluZyB0aGUgcmVjb3JkIG9mIGFuIGFscmVhZHkgZXhpc3Rpbmcgbm9kZS4gU3RhcnRzIHdpdGhcclxuICAgIC8vIHRoZSBwYXJlbnQgb2YgYW4gYWZmZWN0ZWQgbm9kZSBhbmQgYnViYmxlcyB1cCB0byByb290XHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVNYXhPZlBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5yaWdodC5tYXgsIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIExlZnQtTGVmdCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgICB5ICAgVDQgICAgICBSaWdodCBSb3RhdGUgKHopICAgICAgICAgIHggICAgIHpcclxuICAgICAgICAvIFxcICAgICAgICAgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgIFQzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcXHJcbiAgICBUMSAgIFQyXHJcbiAgXHJcbiAgICBMZWZ0LVJpZ2h0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICB5ICAgVDQgIExlZnQgUm90YXRlICh5KSAgICAgICAgIHggIFQ0ICBSaWdodCBSb3RhdGUoeikgICAgIHkgICAgIHpcclxuICAgICAgLyBcXCAgICAgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgICAgIC0gLSAtIC0gLSAtIC0gLT4gIC8gXFwgICAvIFxcXHJcbiAgICBUMSAgIHggICAgICAgICAgICAgICAgICAgICAgICAgICB5ICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgICBUMiAgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyXHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBMZWZ0LUxlZnQgY2FzZSBhbmQgTGVmdC1SaWdodCBjYXNlIGFmdGVyIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBwYXJlbnQubGVmdDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGxlZnQgc2libGluZyAoeCBpbiBmaXJzdCBjYXNlLCB5IGluIHNlY29uZClcclxuICAgICAgICB2YXIgdGhpc1BhcmVudExlZnRIaWdoID0gbGVmdC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVmdC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gdGhpc1BhcmVudExlZnRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heChNYXRoLm1heChsZWZ0LmxlZnQubWF4LCBsZWZ0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRMZWZ0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHBhcmVudC5yaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFJpZ2h0LVJpZ2h0IGNhc2U6XHJcbiAgXHJcbiAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICBUMSAgeSAgICAgTGVmdCBSb3RhdGUoeikgICAgICAgeiAgICAgeFxyXG4gICAgICAgLyBcXCAgIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAvIFxcXHJcbiAgICAgIFQyICB4ICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgIC8gXFxcclxuICAgICAgICBUMyBUNFxyXG4gIFxyXG4gICAgUmlnaHQtTGVmdCBjYXNlOlxyXG4gIFxyXG4gICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICBUMSAgeSAgIFJpZ2h0IFJvdGF0ZSAoeSkgICAgIFQxICB4ICAgICAgTGVmdCBSb3RhdGUoeikgICB6ICAgICB5XHJcbiAgICAgICAgLyBcXCAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgLyBcXCAgIC0gLSAtIC0gLSAtIC0gLT4gIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICBUNCAgICAgICAgICAgICAgICAgICAgICAgIFQyICB5ICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICBUMiAgIFQzICAgICAgICAgICAgICAgICAgICAgICAgICAgVDMgVDRcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIFJpZ2h0LVJpZ2h0IGNhc2UgYW5kIFJpZ2h0LUxlZnQgY2FzZSBpbiByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyZW50LnJpZ2h0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcmlnaHQgc2libGluZyAoeCBpbiBmaXJzdCBjYXNlLCB5IGluIHNlY29uZClcclxuICAgICAgICB2YXIgdGhpc1BhcmVudFJpZ2h0SGlnaCA9IHJpZ2h0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRSaWdodEhpZ2gsIHJpZ2h0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRSaWdodEhpZ2gsIHJpZ2h0LmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gdGhpc1BhcmVudFJpZ2h0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHJpZ2h0LmxlZnQubWF4LCByaWdodC5yaWdodC5tYXgpLCB0aGlzUGFyZW50UmlnaHRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9sZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByaWdodENoaWxkID0gdGhpcy5yaWdodDtcclxuICAgICAgICByaWdodENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlLnJvb3QgPSByaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LmxlZnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5yaWdodCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0Q2hpbGQubGVmdDtcclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRDaGlsZC5sZWZ0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICByaWdodENoaWxkLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9yaWdodFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVmdENoaWxkID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIGxlZnRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobGVmdENoaWxkLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxUcmVlLnJvb3QgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGVmdENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5yaWdodCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0Q2hpbGQucmlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZWZ0Q2hpbGQucmlnaHQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgbGVmdENoaWxkLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlYmFsYW5jZXMgdGhlIHRyZWUgaWYgdGhlIGhlaWdodCB2YWx1ZSBiZXR3ZWVuIHR3byBub2RlcyBvZiB0aGUgc2FtZSBwYXJlbnQgaXMgZ3JlYXRlciB0aGFuXHJcbiAgICAvLyB0d28uIFRoZXJlIGFyZSA0IGNhc2VzIHRoYXQgY2FuIGhhcHBlbiB3aGljaCBhcmUgb3V0bGluZWQgaW4gdGhlIGdyYXBoaWNzIGFib3ZlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmViYWxhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChoZWlnaHQodGhpcy5sZWZ0KSA+PSAyICsgaGVpZ2h0KHRoaXMucmlnaHQpKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KGxlZnQubGVmdCkgPj0gaGVpZ2h0KGxlZnQucmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtUmlnaHQgY2FzZVxyXG4gICAgICAgICAgICAgICAgbGVmdC5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHQodGhpcy5yaWdodCkgPj0gMiArIGhlaWdodCh0aGlzLmxlZnQpKSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQocmlnaHQucmlnaHQpID49IGhlaWdodChyaWdodC5sZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtUmlnaHQgY2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHJpZ2h0Ll9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gbGVmdCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3IE5vZGUodGhpcy5pbnRlcnZhbFRyZWUsIHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gcmlnaHQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmV3IE5vZGUodGhpcy5pbnRlcnZhbFRyZWUsIHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWF4IHZhbHVlIG9mIHRoaXMgYW5jZXN0b3IgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKHRoaXMubWF4IDwgcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIGhlaWdodCBvZiBlYWNoIG5vZGVcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIC8vIFJlYmFsYW5jZSB0aGUgdHJlZSB0byBlbnN1cmUgYWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIGluIE8obG9nbikgdGltZS4gVGhpcyBpcyBlc3BlY2lhbGx5XHJcbiAgICAgICAgLy8gaW1wb3J0YW50IGluIHNlYXJjaGluZywgYXMgdGhlIHRyZWUgaGFzIGEgaGlnaCBjaGFuY2Ugb2YgZGVnZW5lcmF0aW5nIHdpdGhvdXQgdGhlIHJlYmFsYW5jaW5nXHJcbiAgICAgICAgdGhpcy5fcmViYWxhbmNlKCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2dldE92ZXJsYXBwaW5nUmVjb3JkcyA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSwgbG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLmtleSA8PSBoaWdoICYmIGxvdyA8PSBjdXJyZW50Tm9kZS5nZXROb2RlSGlnaCgpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGVzIGFyZSBvdmVybGFwcGluZywgY2hlY2sgaWYgaW5kaXZpZHVhbCByZWNvcmRzIGluIHRoZSBub2RlIGFyZSBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICB2YXIgdGVtcFJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmVjb3Jkc1tpXS5oaWdoID49IGxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBSZXN1bHRzLnB1c2goY3VycmVudE5vZGUucmVjb3Jkc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRlbXBSZXN1bHRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIC8vIERvbid0IHNlYXJjaCBub2RlcyB0aGF0IGRvbid0IGV4aXN0XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0U2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIG93blNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciByaWdodFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHBvaW50IG9mIGFueSBpbnRlcnZhbCBpbiB0aGlzIG5vZGUgYW5kIGFsbCBpdHNcclxuICAgICAgICAvLyBjaGlsZHJlbiwgdGhlcmUgd29uJ3QgYmUgYW55IG1hdGNoZXNcclxuICAgICAgICBpZiAobG93ID4gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWFyY2ggbGVmdCBjaGlsZHJlblxyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxlZnQubWF4ID49IGxvdykge1xyXG4gICAgICAgICAgICBsZWZ0U2VhcmNoID0gdGhpcy5sZWZ0LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcclxuICAgICAgICBvd25TZWFyY2ggPSB0aGlzLl9nZXRPdmVybGFwcGluZ1JlY29yZHModGhpcywgbG93LCBoaWdoKTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgb2YgdGhpcyBpbnRlcnZhbCwgdGhlbiBpdCBjYW4ndCBiZSBpbiBhbnkgY2hpbGQgdG9cclxuICAgICAgICAvLyB0aGUgcmlnaHRcclxuICAgICAgICBpZiAoaGlnaCA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHNlYXJjaCByaWdodCBjaGlsZHJlblxyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHRTZWFyY2ggPSB0aGlzLnJpZ2h0LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXR1cm4gYWNjdW11bGF0ZWQgcmVzdWx0cywgaWYgYW55XHJcbiAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCwgcmlnaHRTZWFyY2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFNlYXJjaGVzIGZvciBhIG5vZGUgYnkgYSBga2V5YCB2YWx1ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuc2VhcmNoRXhpc3RpbmcgPSBmdW5jdGlvbiAobG93KSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5rZXkgPT09IGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG93IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LnNlYXJjaEV4aXN0aW5nKGxvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnNlYXJjaEV4aXN0aW5nKGxvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBub2RlIG9mIHRoZSBzdWJ0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbWluVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5fbWluVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKG5vZGUua2V5IDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5rZXkgPiB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSBoYXMgdHdvIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWluVmFsdWUgPSB0aGlzLnJpZ2h0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBtaW5WYWx1ZS5rZXk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZHMgPSBtaW5WYWx1ZS5yZWNvcmRzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgY2hpbGQgb3Igbm8gY2hpbGQgY2FzZSBvbiBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3JlYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgY2hpbGQgb3Igbm8gY2hpbGQgY2FzZSBvbiByaWdodCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3JlYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XHJcbnZhciBJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnRlcnZhbFRyZWUoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA+IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd2AgdmFsdWUgbXVzdCBiZSBsb3dlciBvciBlcXVhbCB0byBgaGlnaGAgdmFsdWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIEJhc2UgY2FzZTogVHJlZSBpcyBlbXB0eSwgbmV3IG5vZGUgYmVjb21lcyByb290XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBOb2RlKHRoaXMsIHJlY29yZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIG5vZGUgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBrZXlcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByZWNvcmRzIGluIHRoaXMgbm9kZSBpZiB0aGVyZSBhbHJlYWR5IGlzIHRoZSBvbmUgd2l0aCBzYW1lIGxvdywgaGlnaCwgZGF0YVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1tpXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlY29yZCBpcyBzYW1lIGFzIHRoZSBvbmUgd2UncmUgdHJ5aW5nIHRvIGluc2VydDsgcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaGFzIGJlZW4gaW5zZXJ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVjb3JkIHRvIHRoZSBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1heCBvZiB0aGUgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPiBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC4gQ2FsbCBpbnNlcnQgZnVuY3Rpb24gb24gcm9vdCdzIG5vZGVcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyByZXR1cm4gZW1wdHkgYXJyYXlcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IG5vdGhpbmcgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkUmVjb3JkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyAyIG9yIG1vcmUgcmVjb3Jkcy4gRmluZCB0aGUgb25lIHdlIG5lZWQgYW5kIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1tpXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gbm9kZS5yZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlY29yZHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1heCBvZiB0aGF0IG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA9PT0gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVIaWdoID0gbm9kZS5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGUucmlnaHQubWF4KSwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUucmlnaHQubWF4LCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IG5vZGVIaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgb25seSAxIHJlY29yZC4gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyByZWNvcmQgaW4gdGhpcyBub2RlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTYW1lKG5vZGUucmVjb3Jkc1swXSwgcmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmUuIFJlbW92ZSB0aGUgd2hvbGUgbm9kZSBmcm9tIHRoZSB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5rZXkgPT09IG5vZGUua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIHRoZSByb290IGVsZW1lbnQuIENyZWF0ZSBhIGR1bW15IG5vZGUgdGhhdCB3aWxsIHRlbXBvcmFyaWx5IHRha2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm9vdCdzIHBhcmVudCByb2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290UGFyZW50ID0gbmV3IE5vZGUodGhpcywgeyBsb3c6IHJlY29yZC5sb3csIGhpZ2g6IHJlY29yZC5sb3cgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RQYXJlbnQubGVmdCA9IHRoaXMucm9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHJvb3RQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3RQYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgbm90IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyByZWNvcmRzIGF0IGFsbCBpbiB0aGlzIG5vZGU/ISBTaG91bGRuJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5PcmRlcih0aGlzLnJvb3QpO1xyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucHJlT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVPcmRlcih0aGlzLnJvb3QpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW50ZXJ2YWxUcmVlID0gSW50ZXJ2YWxUcmVlO1xyXG52YXIgRGF0YUludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFJbnRlcnZhbFRyZWUoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xyXG4gICAgfVxyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5zZXJ0KHsgbG93OiBsb3csIGhpZ2g6IGhpZ2gsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucmVtb3ZlKHsgbG93OiBsb3csIGhpZ2g6IGhpZ2gsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuc2VhcmNoKGxvdywgaGlnaCkubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmRhdGE7IH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbk9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUucHJlT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5wcmVPcmRlcigpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZSwgXCJjb3VudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWUuY291bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRGF0YUludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUludGVydmFsVHJlZTtcclxudmFyIEluT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbk9yZGVyKHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuICAgICAgICBpZiAoc3RhcnROb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSW5PcmRlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBXaWxsIG9ubHkgaGFwcGVuIGlmIHN0YWNrIGlzIGVtcHR5IGFuZCBwb3AgaXMgY2FsbGVkXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhpcyBub2RlXHJcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkc1t0aGlzLmkrK10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWlnaHQgcG9wIHRoZSBsYXN0IGFuZCBzZXQgdGhpcy5jdXJyZW50Tm9kZSA9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB3aGlsZSAodGhpcy5jdXJyZW50Tm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5jdXJyZW50Tm9kZS5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5PcmRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Jbk9yZGVyID0gSW5PcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIEluT3JkZXIucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG59XHJcbnZhciBQcmVPcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZU9yZGVyKHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICB9XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBXaWxsIG9ubHkgaGFwcGVuIGlmIHN0YWNrIGlzIGVtcHR5IGFuZCBwb3AgaXMgY2FsbGVkLFxyXG4gICAgICAgIC8vIHdoaWNoIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyByaWdodCBub2RlIChpLmUgd2UgYXJlIGRvbmUpXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhpcyBub2RlXHJcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY3VycmVudE5vZGUucmVjb3Jkc1t0aGlzLmkrK10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY3VycmVudE5vZGUubGVmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVPcmRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5QcmVPcmRlciA9IFByZU9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy90eWxlci9wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvdHlsZXIvcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmYXN0LWxldmVuc2h0ZWluXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZmFzdC1sZXZlbnNodGVpblwiXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7XG5cbi8vIFRoZSBkZWJ1ZyBmdW5jdGlvbiBpcyBleGNsdWRlZCBlbnRpcmVseSBmcm9tIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuLyogbm9taW4gKi8gdmFyIGRlYnVnO1xuLyogbm9taW4gKi8gaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52ICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAgIC8qIG5vbWluICovIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIG5vbWluICovIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAvKiBub21pbiAqLyBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgIC8qIG5vbWluICovIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIC8qIG5vbWluICovIH07XG4vKiBub21pbiAqLyBlbHNlXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcblxudmFyIE1BWF9MRU5HVEggPSAyNTY7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbnZhciBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTY7XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG52YXIgcmUgPSBleHBvcnRzLnJlID0gW107XG52YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXTtcbnZhciBSID0gMDtcblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxudmFyIE5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbnZhciBOVU1FUklDSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdID0gJ1swLTldKyc7XG5cblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudmFyIE5PTk5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcblxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudmFyIE1BSU5WRVJTSU9OID0gUisrO1xuc3JjW01BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgTUFJTlZFUlNJT05MT09TRSA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpJztcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVIgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgUFJFUkVMRUFTRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknO1xuXG52YXIgUFJFUkVMRUFTRUxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbnZhciBCVUlMRElERU5USUZJRVIgPSBSKys7XG5zcmNbQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBCVUlMRCA9IFIrKztcbnNyY1tCVUlMRF0gPSAnKD86XFxcXCsoJyArIHNyY1tCVUlMRElERU5USUZJRVJdICtcbiAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW0JVSUxESURFTlRJRklFUl0gKyAnKSopKSc7XG5cblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnZhciBGVUxMID0gUisrO1xudmFyIEZVTExQTEFJTiA9ICd2PycgKyBzcmNbTUFJTlZFUlNJT05dICtcbiAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnNyY1tGVUxMXSA9ICdeJyArIEZVTExQTEFJTiArICckJztcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxudmFyIExPT1NFUExBSU4gPSAnW3Y9XFxcXHNdKicgKyBzcmNbTUFJTlZFUlNJT05MT09TRV0gK1xuICAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICc/JyArXG4gICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnZhciBMT09TRSA9IFIrKztcbnNyY1tMT09TRV0gPSAnXicgKyBMT09TRVBMQUlOICsgJyQnO1xuXG52YXIgR1RMVCA9IFIrKztcbnNyY1tHVExUXSA9ICcoKD86PHw+KT89PyknO1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG52YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG52YXIgWFJBTkdFSURFTlRJRklFUiA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKic7XG5cbnZhciBYUkFOR0VQTEFJTiA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTl0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0UgPSBSKys7XG5zcmNbWFJBTkdFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBYUkFOR0VMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG52YXIgQ09FUkNFID0gUisrO1xuc3JjW0NPRVJDRV0gPSAnKD86XnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pJyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86JHxbXlxcXFxkXSknO1xuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudmFyIExPTkVUSUxERSA9IFIrKztcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknO1xuXG52YXIgVElMREVUUklNID0gUisrO1xuc3JjW1RJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVUSUxERV0gKyAnXFxcXHMrJztcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpO1xudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcblxudmFyIFRJTERFID0gUisrO1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBUSUxERUxPT1NFID0gUisrO1xuc3JjW1RJTERFTE9PU0VdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrO1xuc3JjW0xPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcblxudmFyIENBUkVUVFJJTSA9IFIrKztcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTtcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG5cbnZhciBDQVJFVCA9IFIrKztcbnNyY1tDQVJFVF0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgQ0FSRVRMT09TRSA9IFIrKztcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKztcbnNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICcpJHxeJCc7XG52YXIgQ09NUEFSQVRPUiA9IFIrKztcbnNyY1tDT01QQVJBVE9SXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIEZVTExQTEFJTiArICcpJHxeJCc7XG5cblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnZhciBDT01QQVJBVE9SVFJJTSA9IFIrKztcbnNyY1tDT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0dUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJ3wnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJztcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpO1xudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnO1xuXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG52YXIgSFlQSEVOUkFOR0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnZhciBTVEFSID0gUisrO1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConO1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pO1xuICBpZiAoIXJlW2ldKVxuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF07XG4gIGlmICghci50ZXN0KHZlcnNpb24pKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkO1xuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucyk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gb3B0aW9ucy5sb29zZSlcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIGVsc2VcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcblxuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXSk7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gIHRoaXMucmF3ID0gdmVyc2lvbjtcblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV07XG4gIHRoaXMubWlub3IgPSArbVsyXTtcbiAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIGVsc2VcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkO1xuICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pO1xuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaDtcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJyk7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpO1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG5cbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldO1xuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gIH0gd2hpbGUgKCsraSk7XG59O1xuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKTtcbiAgfVxuICB0aGlzLmZvcm1hdCgpO1xuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnRzLmluYyA9IGluYztcbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2U7XG4gICAgbG9vc2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvbjtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZnVuY3Rpb24gZGlmZih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSk7XG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByZScra2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdwcmVyZWxlYXNlJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYTtcbiAgICBiID0gK2I7XG4gIH1cblxuICByZXR1cm4gKGFudW0gJiYgIWJudW0pID8gLTEgOlxuICAgICAgICAgKGJudW0gJiYgIWFudW0pID8gMSA6XG4gICAgICAgICBhIDwgYiA/IC0xIDpcbiAgICAgICAgIGEgPiBiID8gMSA6XG4gICAgICAgICAwO1xufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcbmZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKTtcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5mdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuZnVuY3Rpb24gcmNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuZnVuY3Rpb24gc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydDtcbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZ3QgPSBndDtcbmZ1bmN0aW9uIGd0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG59XG5cbmV4cG9ydHMubHQgPSBsdDtcbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcbmZ1bmN0aW9uIGVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXE7XG5mdW5jdGlvbiBuZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZTtcbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5mdW5jdGlvbiBsdGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG59XG5cbmV4cG9ydHMuY21wID0gY21wO1xuZnVuY3Rpb24gY21wKGEsIG9wLCBiLCBsb29zZSkge1xuICB2YXIgcmV0O1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSA9PT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgIT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcnOiBjYXNlICc9JzogY2FzZSAnPT0nOiByZXQgPSBlcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJyE9JzogcmV0ID0gbmVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPic6IHJldCA9IGd0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPj0nOiByZXQgPSBndGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8JzogcmV0ID0gbHQoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8PSc6IHJldCA9IGx0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG5cbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSlcbiAgICAgIHJldHVybiBjb21wO1xuICAgIGVsc2VcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKVxuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBvcHRpb25zKTtcblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgZWxzZVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBtID0gY29tcC5tYXRjaChyKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV07XG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpXG4gICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pXG4gICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gIGVsc2VcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucyk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oY29tcCwgb3B0aW9ucykge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICB2YXIgcmFuZ2VUbXA7XG5cbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb247XG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JykpO1xuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW47XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgIGlmIChyYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2U7XG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24oY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgfSkuam9pbignfHwnKS50cmltKCk7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2U7XG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXTtcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpO1xuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVtDT01QQVJBVE9SVFJJTV0pO1xuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpO1xuICB9LCB0aGlzKS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbihjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucyk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiBzZXQ7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICB9KTtcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gIHJldHVybiBjb21wO1xufVxuXG5mdW5jdGlvbiBpc1goaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbn1cblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZVxuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKTtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24ocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKVxuICAgICAgZ3RsdCA9ICcnO1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSlcbiAgICAgICAgbSA9IDA7XG4gICAgICBpZiAoeHApXG4gICAgICAgIHAgPSAwO1xuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49JztcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgaWYgKHhtKVxuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwO1xuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpO1xuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UoJDAsXG4gICAgICAgICAgICAgICAgICAgICAgIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG5cbiAgaWYgKGlzWChmTSkpXG4gICAgZnJvbSA9ICcnO1xuICBlbHNlIGlmIChpc1goZm0pKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWChmcCkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJztcbiAgZWxzZVxuICAgIGZyb20gPSAnPj0nICsgZnJvbTtcblxuICBpZiAoaXNYKHRNKSlcbiAgICB0byA9ICcnO1xuICBlbHNlIGlmIChpc1godG0pKVxuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1godHApKVxuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnO1xuICBlbHNlIGlmICh0cHIpXG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICBlbHNlXG4gICAgdG8gPSAnPD0nICsgdG87XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn1cblxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGVzdFNldChzZXQsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllcztcbmZ1bmN0aW9uIHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1heFNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgeyAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4O1xufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1pbiA9IG51bGw7XG4gIHZhciBtaW5TViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgeyAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluO1xufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlO1xuZnVuY3Rpb24gdmFsaWRSYW5nZShyYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHI7XG5mdW5jdGlvbiBndHIodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMub3V0c2lkZSA9IG91dHNpZGU7XG5mdW5jdGlvbiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcDtcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3Q7XG4gICAgICBsdGVmbiA9IGx0ZTtcbiAgICAgIGx0Zm4gPSBsdDtcbiAgICAgIGNvbXAgPSAnPic7XG4gICAgICBlY29tcCA9ICc+PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdDtcbiAgICAgIGx0ZWZuID0gZ3RlO1xuICAgICAgbHRmbiA9IGd0O1xuICAgICAgY29tcCA9ICc8JztcbiAgICAgIGVjb21wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpO1xuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG5cbiAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgdmFyIGxvdyA9IG51bGw7XG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yO1xuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcbmZ1bmN0aW9uIHByZXJlbGVhc2UodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucyk7XG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgb3B0aW9ucykge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmZ1bmN0aW9uIGNvZXJjZSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVtDT0VSQ0VdKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gcGFyc2UoKG1hdGNoWzFdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbMl0gfHwgJzAnKSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpKTsgXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvdHlsZXIvcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIGFsbCwgZm9yaywgdGFrZSwgcHV0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFzdCBmcm9tIFwibGliL2FzdC9zYWdhc1wiO1xuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvc2FnYXNcIjtcbmltcG9ydCAqIGFzIHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGV2bSBmcm9tIFwibGliL2V2bS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZGF0YSBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcbmltcG9ydCAqIGFzIHdlYjMgZnJvbSBcImxpYi93ZWIzL3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICBkZWJ1ZyhcInN0YXJ0aW5nIGxpc3RlbmVyc1wiKTtcbiAgeWllbGQqIGZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQqIHJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIndhaXRpbmcgZm9yIHN0YXJ0XCIpO1xuICAvLyB3YWl0IGZvciBzdGFydCBzaWduYWxcbiAgbGV0IHsgdHhIYXNoLCBwcm92aWRlciB9ID0geWllbGQgdGFrZShhY3Rpb25zLlNUQVJUKTtcbiAgZGVidWcoXCJzdGFydGluZ1wiKTtcblxuICAvLyBwcm9jZXNzIHRyYW5zYWN0aW9uXG4gIGRlYnVnKFwiZmV0Y2hpbmcgdHJhbnNhY3Rpb24gaW5mb1wiKTtcbiAgbGV0IGVyciA9IHlpZWxkKiBmZXRjaFR4KHR4SGFzaCwgcHJvdmlkZXIpO1xuICBpZiAoZXJyKSB7XG4gICAgZGVidWcoXCJlcnJvciAlb1wiLCBlcnIpO1xuICAgIHlpZWxkKiBlcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKFwidmlzaXRpbmcgQVNUc1wiKTtcbiAgICAvLyB2aXNpdCBhc3RzXG4gICAgeWllbGQqIGFzdC52aXNpdEFsbCgpO1xuXG4gICAgLy9zYXZlIGFsbG9jYXRpb24gdGFibGVcbiAgICBkZWJ1ZyhcInNhdmluZyBhbGxvY2F0aW9uIHRhYmxlXCIpO1xuICAgIHlpZWxkKiBkYXRhLnJlY29yZEFsbG9jYXRpb25zKCk7XG5cbiAgICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAgIC8vIHNpZ25hbCB0aGF0IHN0ZXBwaW5nIGNhbiBiZWdpblxuICAgIHlpZWxkKiByZWFkeSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJzZXNzaW9uXCIsIHNhZ2EpO1xuXG5mdW5jdGlvbiogZm9ya0xpc3RlbmVycygpIHtcbiAgcmV0dXJuIHlpZWxkIGFsbChcbiAgICBbY29udHJvbGxlciwgZGF0YSwgZXZtLCBzb2xpZGl0eSwgdHJhY2UsIHdlYjNdLm1hcChcbiAgICAgIGFwcCA9PiBmb3JrKGFwcC5zYWdhKVxuICAgICAgLy9hc3Qgbm8gbG9uZ2VyIGhhcyBhIGxpc3RlbmVyXG4gICAgKVxuICApO1xufVxuXG5mdW5jdGlvbiogZmV0Y2hUeCh0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIGxldCByZXN1bHQgPSB5aWVsZCogd2ViMy5pbnNwZWN0VHJhbnNhY3Rpb24odHhIYXNoLCBwcm92aWRlcik7XG5cbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiByZXN1bHQuZXJyb3I7XG4gIH1cblxuICB5aWVsZCogZXZtLmJlZ2luKHJlc3VsdCk7XG5cbiAgbGV0IGFkZHJlc3NlcyA9IHlpZWxkKiB0cmFjZS5wcm9jZXNzVHJhY2UocmVzdWx0LnRyYWNlKTtcbiAgaWYgKHJlc3VsdC5hZGRyZXNzICYmIGFkZHJlc3Nlcy5pbmRleE9mKHJlc3VsdC5hZGRyZXNzKSA9PSAtMSkge1xuICAgIGFkZHJlc3Nlcy5wdXNoKHJlc3VsdC5hZGRyZXNzKTtcbiAgfVxuXG4gIGxldCBiaW5hcmllcyA9IHlpZWxkKiB3ZWIzLm9idGFpbkJpbmFyaWVzKGFkZHJlc3Nlcyk7XG5cbiAgeWllbGQgYWxsKFxuICAgIGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MsIGkpID0+IGNhbGwocmVjb3JkSW5zdGFuY2UsIGFkZHJlc3MsIGJpbmFyaWVzW2ldKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24qIHJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKSB7XG4gIGZvciAobGV0IHsgY29udHJhY3ROYW1lLCBiaW5hcnksIHNvdXJjZU1hcCwgY29tcGlsZXIgfSBvZiBjb250ZXh0cykge1xuICAgIHlpZWxkKiBldm0uYWRkQ29udGV4dChjb250cmFjdE5hbWUsIHsgYmluYXJ5IH0sIGNvbXBpbGVyKTtcblxuICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgIHlpZWxkKiBzb2xpZGl0eS5hZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBzb3VyY2VzW2ldO1xuICAgIGlmIChzb3VyY2VEYXRhICE9PSB1bmRlZmluZWQgJiYgc291cmNlRGF0YSAhPT0gbnVsbCkge1xuICAgICAgeWllbGQqIHNvbGlkaXR5LmFkZFNvdXJjZShcbiAgICAgICAgc291cmNlRGF0YS5zb3VyY2UsXG4gICAgICAgIHNvdXJjZURhdGEuc291cmNlUGF0aCxcbiAgICAgICAgc291cmNlRGF0YS5hc3RcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgeWllbGQqIGV2bS5hZGRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiogcmVhZHkoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlYWR5KCkpO1xufVxuXG5mdW5jdGlvbiogZXJyb3IoZXJyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGVycikpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiogd2Fsayhzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciA9IFwiXCIsIHBhcmVudElkID0gbnVsbCkge1xuICBkZWJ1ZyhcIndhbGtpbmcgJW8gJW9cIiwgcG9pbnRlciwgbm9kZSk7XG5cbiAgeWllbGQqIGhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2l9YCwgcGFyZW50SWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yIChsZXQgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtrZXl9YCwgbm9kZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgeWllbGQqIGhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpO1xufVxuXG5mdW5jdGlvbiogaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJlbnRlcmluZyAlc1wiLCBwb2ludGVyKTtcblxuICBpZiAobm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCIlcyByZWNvcmRpbmcgc2NvcGUgJXNcIiwgcG9pbnRlciwgbm9kZS5pZCk7XG4gICAgeWllbGQqIGRhdGEuc2NvcGUobm9kZS5pZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyB2YXJpYWJsZSAlb1wiLCBwb2ludGVyLCBub2RlKTtcbiAgICAgIHlpZWxkKiBkYXRhLmRlY2xhcmUobm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgY2FzZSBcIlN0cnVjdERlZmluaXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlZmluaXRpb25cIjpcbiAgICAgIHlpZWxkKiBkYXRhLmRlZmluZVR5cGUobm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiogaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcikge1xuICBkZWJ1ZyhcImV4aXRpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgLy8gbm8tb3AgcmlnaHQgbm93XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdmlzaXRBbGwoKSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoKFtfLCBzb3VyY2VdKSA9PiBzb3VyY2UuYXN0KVxuICAgICAgLm1hcCgoW2lkLCB7IGFzdCB9XSkgPT4gY2FsbCh3YWxrLCBpZCwgYXN0KSlcbiAgKTtcblxuICBkZWJ1ZyhcImRvbmUgdmlzaXRpbmdcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIGNhbGwsIHJhY2UsIHRha2UsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBDT05UUk9MX1NBR0FTID0ge1xuICBbYWN0aW9ucy5BRFZBTkNFXTogYWR2YW5jZSxcbiAgW2FjdGlvbnMuU1RFUF9ORVhUXTogc3RlcE5leHQsXG4gIFthY3Rpb25zLlNURVBfT1ZFUl06IHN0ZXBPdmVyLFxuICBbYWN0aW9ucy5TVEVQX0lOVE9dOiBzdGVwSW50byxcbiAgW2FjdGlvbnMuU1RFUF9PVVRdOiBzdGVwT3V0LFxuICBbYWN0aW9ucy5DT05USU5VRV06IGNvbnRpbnVlVW50aWxCcmVha3BvaW50LFxuICBbYWN0aW9ucy5SRVNFVF06IHJlc2V0XG59O1xuXG4vKiogQVNUIG5vZGUgdHlwZXMgdGhhdCBhcmUgc2tpcHBlZCB0byBmaWx0ZXIgb3V0IHNvbWUgbm9pc2UgKi9cbmNvbnN0IFNLSVBQRURfVFlQRVMgPSBuZXcgU2V0KFtcIkNvbnRyYWN0RGVmaW5pdGlvblwiLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIl0pO1xuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhDT05UUk9MX1NBR0FTKSk7XG4gICAgZGVidWcoXCJnb3QgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IHNhZ2EgPSBDT05UUk9MX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmJlZ2luU3RlcChhY3Rpb24udHlwZSkpO1xuXG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImNvbnRyb2xsZXJcIiwgc2FnYSk7XG5cbi8qKlxuICogQWR2YW5jZSB0aGUgc3RhdGUgYnkgb25lIGluc3RydWN0aW9uXG4gKi9cbmZ1bmN0aW9uKiBhZHZhbmNlKCkge1xuICAvLyBzZW5kIGFjdGlvbiB0byBhZHZhbmNlIHRyYWNlXG4gIHlpZWxkKiB0cmFjZS5hZHZhbmNlKCk7XG59XG5cbi8qKlxuICogc3RlcE5leHQgLSBzdGVwIHRvIHRoZSBuZXh0IGxvZ2ljYWwgY29kZSBzZWdtZW50XG4gKlxuICogTm90ZTogSXQgbWlnaHQgdGFrZSBtdWx0aXBsZSBpbnN0cnVjdGlvbnMgdG8gZXhwcmVzcyB0aGUgc2FtZSBzZWN0aW9uIG9mIGNvZGUuXG4gKiBcIlN0ZXBwaW5nXCIsIHRoZW4sIGlzIHN0ZXBwaW5nIHRvIHRoZSBuZXh0IGxvZ2ljYWwgaXRlbSwgbm90IHN0ZXBwaW5nIHRvIHRoZSBuZXh0XG4gKiBpbnN0cnVjdGlvbi4gU2VlIGFkdmFuY2UoKSBpZiB5b3UnZCBsaWtlIHRvIGFkdmFuY2UgYnkgb25lIGluc3RydWN0aW9uLlxuICovXG5mdW5jdGlvbiogc3RlcE5leHQoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcblxuICB2YXIgdXBjb21pbmcsIGZpbmlzaGVkO1xuXG4gIGRvIHtcbiAgICAvLyBhZHZhbmNlIGF0IGxlYXN0IG9uY2Ugc3RlcFxuICAgIHlpZWxkKiBhZHZhbmNlKCk7XG5cbiAgICAvLyBhbmQgY2hlY2sgdGhlIG5leHQgc291cmNlIHJhbmdlXG4gICAgdHJ5IHtcbiAgICAgIHVwY29taW5nID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXBjb21pbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGZpbmlzaGVkID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuZmluaXNoZWQpO1xuXG4gICAgLy8gaWYgdGhlIG5leHQgc3RlcCdzIHNvdXJjZSByYW5nZSBpcyBzdGlsbCB0aGUgc2FtZSwga2VlcCBnb2luZ1xuICB9IHdoaWxlIChcbiAgICAhZmluaXNoZWQgJiZcbiAgICAoIXVwY29taW5nIHx8XG4gICAgICAhdXBjb21pbmcubm9kZSB8fFxuICAgICAgU0tJUFBFRF9UWVBFUy5oYXModXBjb21pbmcubm9kZS5ub2RlVHlwZSkgfHxcbiAgICAgICh1cGNvbWluZy5zb3VyY2VSYW5nZS5zdGFydCA9PSBzdGFydGluZ1JhbmdlLnN0YXJ0ICYmXG4gICAgICAgIHVwY29taW5nLnNvdXJjZVJhbmdlLmxlbmd0aCA9PSBzdGFydGluZ1JhbmdlLmxlbmd0aCkpXG4gICk7XG59XG5cbi8qKlxuICogc3RlcEludG8gLSBzdGVwIGludG8gdGhlIGN1cnJlbnQgZnVuY3Rpb25cbiAqXG4gKiBDb25jZXB0dWFsbHkgdGhpcyBpcyBlYXN5LCBidXQgZnJvbSBhIHByb2dyYW1taW5nIHN0YW5kcG9pbnQgaXQncyBoYXJkLlxuICogQ29kZSBsaWtlIGBnZXRCYWxhbmNlKG1zZy5zZW5kZXIpYCBtaWdodCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZXJlIGNvdWxkXG4gKiBiZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgaW50ZXJtZWRpYXRlIHN0ZXBzIChsaWtlIGV2YWx1YXRpbmcgYG1zZy5zZW5kZXJgKVxuICogYmVmb3JlIGBnZXRCYWxhbmNlYCBpcyBzdGVwcGVkIGludG8uIFRoaXMgZnVuY3Rpb24gd2lsbCBzdGVwIGludG8gdGhlIGZpcnN0XG4gKiBmdW5jdGlvbiBhdmFpbGFibGUgKHdoZXJlIGluc3RydWN0aW9uLmp1bXAgPT0gXCJpXCIpLCBpZ25vcmluZyBhbnkgaW50ZXJtZWRpYXRlXG4gKiBzdGVwcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzYW1lIGNvZGUgcmFuZ2UuIElmIHRoZXJlJ3MgYSBzdGVwIGVuY291bnRlcmVkXG4gKiB0aGF0IGV4aXN0cyBvdXRzaWRlIG9mIHRoZSByYW5nZSwgdGhlbiBzdGVwSW50byB3aWxsIG9ubHkgZXhlY3V0ZSB1bnRpbCB0aGF0XG4gKiBzdGVwLlxuICovXG5mdW5jdGlvbiogc3RlcEludG8oKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQqIHN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIH0gd2hpbGUgKFxuICAgIC8vIHRoZSBmdW5jdGlvbiBzdGFjayBoYXMgbm90IGluY3JlYXNlZCxcbiAgICBjdXJyZW50RGVwdGggPD0gc3RhcnRpbmdEZXB0aCAmJlxuICAgIC8vIHRoZSBjdXJyZW50IHNvdXJjZSByYW5nZSBiZWdpbnMgb24gb3IgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHJhbmdlXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0ID49IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgKyBjdXJyZW50UmFuZ2UubGVuZ3RoIDw9XG4gICAgICBzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBTdGVwIG91dCBvZiB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIFRoaXMgd2lsbCBydW4gdW50aWwgdGhlIGRlYnVnZ2VyIGVuY291bnRlcnMgYSBkZWNyZWFzZSBpbiBmdW5jdGlvbiBkZXB0aC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBPdXQoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkKiBzdGVwT3ZlcigpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgfSB3aGlsZSAoY3VycmVudERlcHRoID49IHN0YXJ0aW5nRGVwdGgpO1xufVxuXG4vKipcbiAqIHN0ZXBPdmVyIC0gc3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmVcbiAqXG4gKiBTdGVwIG92ZXIgdGhlIGN1cnJlbnQgbGluZS4gVGhpcyB3aWxsIHN0ZXAgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gdGhhdFxuICogZXhpc3RzIG9uIGEgZGlmZmVyZW50IGxpbmUgb2YgY29kZSB3aXRoaW4gdGhlIHNhbWUgZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3ZlcigpIHtcbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcbiAgdmFyIGN1cnJlbnRSYW5nZTtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICAgIGN1cnJlbnRSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB9IHdoaWxlIChcbiAgICAvLyBrZWVwIHN0ZXBwaW5nIHByb3ZpZGVkOlxuICAgIC8vXG4gICAgLy8gd2UgaGF2ZW4ndCBqdW1wZWQgb3V0XG4gICAgIShjdXJyZW50RGVwdGggPCBzdGFydGluZ0RlcHRoKSAmJlxuICAgIC8vIGVpdGhlcjogZnVuY3Rpb24gZGVwdGggaXMgZ3JlYXRlciB0aGFuIHN0YXJ0aW5nIChpZ25vcmUgZnVuY3Rpb24gY2FsbHMpXG4gICAgLy8gb3IsIGlmIHdlJ3JlIGF0IHRoZSBzYW1lIGRlcHRoLCBrZWVwIHN0ZXBwaW5nIHVudGlsIHdlJ3JlIG9uIGEgbmV3XG4gICAgLy8gbGluZS5cbiAgICAoY3VycmVudERlcHRoID4gc3RhcnRpbmdEZXB0aCB8fFxuICAgICAgY3VycmVudFJhbmdlLmxpbmVzLnN0YXJ0LmxpbmUgPT0gc3RhcnRpbmdSYW5nZS5saW5lcy5zdGFydC5saW5lKVxuICApO1xufVxuXG4vKipcbiAqIGNvbnRpbnVlVW50aWxCcmVha3BvaW50IC0gc3RlcCB0aHJvdWdoIGV4ZWN1dGlvbiB1bnRpbCBhIGJyZWFrcG9pbnRcbiAqL1xuZnVuY3Rpb24qIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KCkge1xuICB2YXIgY3VycmVudExvY2F0aW9uLCBjdXJyZW50Tm9kZSwgY3VycmVudExpbmUsIGN1cnJlbnRTb3VyY2VJZDtcbiAgdmFyIGZpbmlzaGVkO1xuICB2YXIgcHJldmlvdXNMaW5lLCBwcmV2aW91c1NvdXJjZUlkO1xuXG4gIGxldCBicmVha3BvaW50cyA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmJyZWFrcG9pbnRzKTtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGN1cnJlbnRMb2NhdGlvbiA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRMb2NhdGlvbi5ub2RlLmlkO1xuICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIHByZXZpb3VzTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHByZXZpb3VzU291cmNlSWQgPSBjdXJyZW50U291cmNlSWQ7XG5cbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmZpbmlzaGVkKTtcbiAgICBkZWJ1ZyhcImZpbmlzaGVkICVvXCIsIGZpbmlzaGVkKTtcblxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudExvY2F0aW9uLm5vZGUuaWQ7XG4gICAgY3VycmVudExpbmUgPSBjdXJyZW50TG9jYXRpb24uc291cmNlUmFuZ2UubGluZXMuc3RhcnQubGluZTtcbiAgICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gICAgYnJlYWtwb2ludEhpdCA9XG4gICAgICBicmVha3BvaW50cy5maWx0ZXIoKHsgc291cmNlSWQsIGxpbmUsIG5vZGUgfSkgPT4ge1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVidWcoXCJub2RlICVkIGN1cnJlbnROb2RlICVkXCIsIG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gc291cmNlSWQgPT09IGN1cnJlbnRTb3VyY2VJZCAmJiBub2RlID09PSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvL290aGVyd2lzZSwgd2UgaGF2ZSBhIGxpbmUtc3R5bGUgYnJlYWtwb2ludDsgd2Ugd2FudCB0byBzdG9wIGF0IHRoZVxuICAgICAgICAvLypmaXJzdCogcG9pbnQgb24gdGhlIGxpbmVcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzb3VyY2VJZCA9PT0gY3VycmVudFNvdXJjZUlkICYmXG4gICAgICAgICAgbGluZSA9PT0gY3VycmVudExpbmUgJiZcbiAgICAgICAgICAoY3VycmVudFNvdXJjZUlkICE9PSBwcmV2aW91c1NvdXJjZUlkIHx8IGN1cnJlbnRMaW5lICE9PSBwcmV2aW91c0xpbmUpXG4gICAgICAgICk7XG4gICAgICB9KS5sZW5ndGggPiAwO1xuICB9IHdoaWxlICghYnJlYWtwb2ludEhpdCAmJiAhZmluaXNoZWQpO1xufVxuXG4vKipcbiAqIHJlc2V0IC0tIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgZGVidWdnZXJcbiAqL1xuZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCogZGF0YS5yZXNldCgpO1xuICB5aWVsZCogZXZtLnJlc2V0KCk7XG4gIHlpZWxkKiBzb2xpZGl0eS5yZXNldCgpO1xuICB5aWVsZCogdHJhY2UucmVzZXQoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBhbGwsIHRha2VFdmVyeSwgYXBwbHksIGZvcmssIGpvaW4sIHRha2UsIHB1dCwgc2VsZWN0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgc2Vzc2lvbiBmcm9tIFwibGliL3Nlc3Npb24vYWN0aW9uc1wiO1xuXG5pbXBvcnQgV2ViM0FkYXB0ZXIgZnJvbSBcIi4uL2FkYXB0ZXJcIjtcblxuZnVuY3Rpb24qIGZldGNoVHJhbnNhY3Rpb25JbmZvKGFkYXB0ZXIsIHt0eEhhc2h9KSB7XG4gIGRlYnVnKFwiaW5zcGVjdGluZyB0cmFuc2FjdGlvblwiKTtcbiAgdmFyIHRyYWNlO1xuICB0cnkge1xuICAgIHRyYWNlID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRUcmFjZSwgW3R4SGFzaF0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgZXJyb3JcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZ290IHRyYWNlXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlVHJhY2UodHJhY2UpKTtcblxuICBsZXQgdHggPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYW5zYWN0aW9uLCBbdHhIYXNoXSk7XG4gIGxldCByZWNlaXB0ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRSZWNlaXB0LCBbdHhIYXNoXSk7XG5cbiAgeWllbGQgcHV0KHNlc3Npb24uc2F2ZVRyYW5zYWN0aW9uKHR4KSk7XG4gIHlpZWxkIHB1dChzZXNzaW9uLnNhdmVSZWNlaXB0KHJlY2VpcHQpKTtcblxuICBpZiAodHgudG8gJiYgdHgudG8gIT0gXCIweDBcIikge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVDYWxsKHthZGRyZXNzOiB0eC50b30pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQ2FsbCh7YmluYXJ5OiB0eC5pbnB1dH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJDb3VsZCBub3QgZmluZCBjb250cmFjdCBhc3NvY2lhdGVkIHdpdGggdHJhbnNhY3Rpb24uIFwiICtcbiAgICBcIlBsZWFzZSBtYWtlIHN1cmUgeW91J3JlIGRlYnVnZ2luZyBhIHRyYW5zYWN0aW9uIHRoYXQgZXhlY3V0ZXMgYSBcIiArXG4gICAgXCJjb250cmFjdCBmdW5jdGlvbiBvciBjcmVhdGVzIGEgbmV3IGNvbnRyYWN0LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaEJpbmFyeShhZGFwdGVyLCB7YWRkcmVzc30pIHtcbiAgZGVidWcoXCJmZXRjaGluZyBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICBsZXQgYmluYXJ5ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXREZXBsb3llZENvZGUsIFthZGRyZXNzXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmluaXQocHJvdmlkZXIpKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZSggKHt0eXBlfSkgPT5cbiAgICB0eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSB8fCB0eXBlID09IGFjdGlvbnMuRVJST1JfV0VCM1xuICApO1xuICBkZWJ1ZyhcImFjdGlvbiAlb1wiLCBhY3Rpb24pO1xuXG4gIHZhciB0cmFjZTtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSkge1xuICAgIHRyYWNlID0gYWN0aW9uLnRyYWNlO1xuICAgIGRlYnVnKFwicmVjZWl2ZWQgdHJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICB9XG5cbiAgbGV0IHthZGRyZXNzLCBiaW5hcnl9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQ0FMTCk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgY2FsbFwiKTtcblxuICByZXR1cm4geyB0cmFjZSwgYWRkcmVzcywgYmluYXJ5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqb2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKSB7XG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChcbiAgICBhZGRyZXNzZXMubWFwKCAoYWRkcmVzcykgPT4gZm9yayhyZWNlaXZlQmluYXJ5LCBhZGRyZXNzKSApXG4gICk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MpID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MpKSApXG4gICk7XG5cbiAgbGV0IGJpbmFyaWVzID0gW107XG4gIGJpbmFyaWVzID0geWllbGQgYWxsKFxuICAgIHRhc2tzLm1hcCh0YXNrID0+IGpvaW4odGFzaykpXG4gICk7XG5cbiAgZGVidWcoXCJiaW5hcmllcyAlb1wiLCBiaW5hcmllcyk7XG5cbiAgcmV0dXJuIGJpbmFyaWVzO1xufVxuXG5mdW5jdGlvbiAqcmVjZWl2ZUJpbmFyeShhZGRyZXNzKSB7XG4gIGxldCB7YmluYXJ5fSA9IHlpZWxkIHRha2UoKGFjdGlvbikgPT4gKFxuICAgIGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9CSU5BUlkgJiZcbiAgICBhY3Rpb24uYWRkcmVzcyA9PSBhZGRyZXNzXG4gICkpO1xuICBkZWJ1ZyhcImdvdCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBiaW5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3Igd2ViMyBpbml0IHNpZ25hbFxuICBsZXQge3Byb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgSU5JVF9XRUIzID0gXCJJTklUX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbml0KHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5JVF9XRUIzLFxuICAgIHByb3ZpZGVyXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlNQRUNUID0gXCJJTlNQRUNUX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdCh0eEhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTlNQRUNULFxuICAgIHR4SGFzaFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRkVUQ0hfQklOQVJZID0gXCJGRVRDSF9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEJpbmFyeShhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRkVUQ0hfQklOQVJZLFxuICAgIGFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQklOQVJZID0gXCJSRUNFSVZFX0JJTkFSWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVCaW5hcnkoYWRkcmVzcywgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9CSU5BUlksXG4gICAgYWRkcmVzcyxcbmJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9UUkFDRSA9IFwiUkVDRUlWRV9UUkFDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVUcmFjZSh0cmFjZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfVFJBQ0UsXG4gICAgdHJhY2VcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQ0FMTCA9IFwiUkVDRUlWRV9DQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUNhbGwoe2FkZHJlc3MsIGJpbmFyeX0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0NBTEwsXG4gICAgYWRkcmVzcyxcbmJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1JfV0VCMyA9IFwiRVJST1JfV0VCM1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRVJST1JfV0VCMyxcbiAgICBlcnJvclxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOmFkYXB0ZXJcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYjNBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICB0aGlzLndlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gIH1cblxuICBhc3luYyBnZXRUcmFjZSh0eEhhc2gpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoIChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53ZWIzLmN1cnJlbnRQcm92aWRlci5zZW5kKHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kOiBcImRlYnVnX3RyYWNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBbdHhIYXNoLCB7fV0sXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgZGVidWcoXCJyZXN1bHQ6ICVvXCIsIHJlc3VsdCk7XG4gICAgICAgIGFjY2VwdChyZXN1bHQucmVzdWx0LnN0cnVjdExvZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb24odHhIYXNoLCAoZXJyLCB0eCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG5cbiAgICAgICAgcmV0dXJuIGFjY2VwdCh0eCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBhc3luYyBnZXRSZWNlaXB0KHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gsIChlcnIsIHJlY2VpcHQpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgIHJldHVybiBhY2NlcHQocmVjZWlwdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0RGVwbG95ZWRDb2RlIC0gZ2V0IHRoZSBkZXBsb3llZCBjb2RlIGZvciBhbiBhZGRyZXNzIGZyb20gdGhlIGNsaWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIGRlcGxveWVkQmluYXJ5XG4gICAqL1xuICBhc3luYyBnZXREZXBsb3llZENvZGUoYWRkcmVzcykge1xuICAgIGRlYnVnKFwiZ2V0dGluZyBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldENvZGUoYWRkcmVzcywgKGVyciwgZGVwbG95ZWRCaW5hcnkpID0+IHtcbiAgICAgICAgaWYgKGVycikgZGVidWcoXCJlcnJvcjogJW9cIiwgZXJyKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBkZWJ1ZyhcImdvdCBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgYWNjZXB0KGRlcGxveWVkQmluYXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FkYXB0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGNvbnN0IFdBSVRJTkcgPSBcIldBSVRJTkdcIjtcbmV4cG9ydCBjb25zdCBBQ1RJVkUgPSBcIkFDVElWRVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJFUlJPUlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhdHVzKHN0YXRlID0gV0FJVElORywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuUkVBRFk6XG4gICAgICByZXR1cm4gQUNUSVZFO1xuXG4gICAgY2FzZSBhY3Rpb25zLkVSUk9SOlxuICAgICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNhY3Rpb24oc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIGFjdGlvbi50cmFuc2FjdGlvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNlaXB0KHN0YXRlID0ge30sIGFjdGlvbikge1xuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9SRUNFSVBUOlxuICAgICAgcmV0dXJuIGFjdGlvbi5yZWNlaXB0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3Qgc2Vzc2lvbiA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHN0YXR1cyxcbiAgdHJhbnNhY3Rpb24sXG4gIHJlY2VpcHRcbn0pO1xuXG5jb25zdCByZWR1Y2VTdGF0ZSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNlc3Npb24sXG4gIGRhdGEsXG4gIGV2bSxcbiAgc29saWRpdHksXG4gIHRyYWNlLFxuICBjb250cm9sbGVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpyZWR1Y2Vyc1wiKTtcblxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IHN0YWJsZUtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TQ09QRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzY29wZXMoc3RhdGUgPSBERUZBVUxUX1NDT1BFUywgYWN0aW9uKSB7XG4gIHZhciBzY29wZTtcbiAgdmFyIHZhcmlhYmxlcztcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNDT1BFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5pZF0gfHwge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5pZF06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgc291cmNlSWQ6IGFjdGlvbi5zb3VyY2VJZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBhY3Rpb24ucGFyZW50SWQsXG4gICAgICAgICAgICBwb2ludGVyOiBhY3Rpb24ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5ERUNMQVJFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5ub2RlLnNjb3BlXSB8fCB7fTtcbiAgICAgIHZhcmlhYmxlcyA9IHNjb3BlLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLm5vZGUuc2NvcGVdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXG4gICAgICAgICAgICAgIC4uLnZhcmlhYmxlcyxcblxuICAgICAgICAgICAgICB7IG5hbWU6IGFjdGlvbi5ub2RlLm5hbWUsIGlkOiBhY3Rpb24ubm9kZS5pZCB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vL2Egbm90ZSBvbiB0aGUgZm9sbG93aW5nIHJlZHVjZXI6IHNvbGlkaXR5IGFzc2lnbnMgYSB1bmlxdWUgQVNUIElEIHRvIGV2ZXJ5XG4vL0FTVCBub2RlIGFtb25nIGFsbCB0aGUgZmlsZXMgYmVpbmcgY29tcGlsZWQgdG9nZXRoZXIuICB0aHVzLCBpdCBpcywgZm9yIG5vdyxcbi8vc2FmZSB0byBpZGVudGlmeSB1c2VyLWRlZmluZWQgdHlwZXMgc29sZWx5IGJ5IHRoZWlyIEFTVCBJRC4gIEluIHRoZSBmdXR1cmUsXG4vL29uY2Ugd2UgZXZlbnR1YWxseSBzdXBwb3J0IGhhdmluZyBzb21lIGZpbGVzIGNvbXBpbGVkIHNlcGFyYXRlbHkgZnJvbSBvdGhlcnMsXG4vL3RoaXMgd2lsbCBiZWNvbWUgYSBidWcgeW91J2xsIGhhdmUgdG8gZml4LCBhbmQgeW91J2xsIGhhdmUgdG8gZml4IGl0IGluIHRoZVxuLy9kZWNvZGVyLCB0b28uICBTb3JyeSwgZnV0dXJlIG1lISAob3Igd2hvZXZlcidzIHN0dWNrIGRvaW5nIHRoaXMpXG5cbmZ1bmN0aW9uIHVzZXJEZWZpbmVkVHlwZXMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuREVGSU5FX1RZUEU6XG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBhY3Rpb24ubm9kZS5pZF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yYWdlKHN0YXRlID0ge30sIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuQUxMT0NBVEUpIHtcbiAgICByZXR1cm4gYWN0aW9uLnN0b3JhZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGFsbG9jYXRpb25zID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc3RvcmFnZVxufSk7XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzY29wZXMsXG4gIHVzZXJEZWZpbmVkVHlwZXMsXG4gIGFsbG9jYXRpb25zXG59KTtcblxuY29uc3QgREVGQVVMVF9BU1NJR05NRU5UUyA9IHtcbiAgYnlJZDoge30sXG4gIGJ5QXN0SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBhc3NpZ25tZW50cyhzdGF0ZSA9IERFRkFVTFRfQVNTSUdOTUVOVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFTU0lHTjpcbiAgICAgIGRlYnVnKFwiYWN0aW9uLmFzc2lnbm1lbnRzICVPXCIsIGFjdGlvbi5hc3NpZ25tZW50cyk7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhY3Rpb24uYXNzaWdubWVudHMuYnlJZCkucmVkdWNlKFxuICAgICAgICAoYWNjLCBhc3NpZ25tZW50KSA9PiB7XG4gICAgICAgICAgbGV0IHsgaWQsIGFzdElkIH0gPSBhc3NpZ25tZW50OyAvL3dlIGRvbid0IG5lZWQgdGhlIHJlc3RcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnlJZDoge1xuICAgICAgICAgICAgICAuLi5hY2MuYnlJZCxcbiAgICAgICAgICAgICAgW2lkXTogYXNzaWdubWVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ5QXN0SWQ6IHtcbiAgICAgICAgICAgICAgLi4uYWNjLmJ5QXN0SWQsXG4gICAgICAgICAgICAgIFthc3RJZF06IFsuLi5uZXcgU2V0KFsuLi4oYWNjLmJ5QXN0SWRbYXN0SWRdIHx8IFtdKSwgaWRdKV1cbiAgICAgICAgICAgICAgLy93ZSB1c2UgYSBzZXQgZm9yIHVuaXF1ZW5lc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZVxuICAgICAgKTtcblxuICAgIGNhc2UgYWN0aW9ucy5MRUFSTl9BRERSRVNTOlxuICAgICAgbGV0IHsgZHVtbXlBZGRyZXNzLCBhZGRyZXNzIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHN0YXRlLmJ5SWQpLm1hcCgoWywgYXNzaWdubWVudF0pID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdBc3NpZ25tZW50ID0gbGVhcm5BZGRyZXNzKGFzc2lnbm1lbnQsIGR1bW15QWRkcmVzcywgYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbbmV3QXNzaWdubWVudC5pZF06IG5ld0Fzc2lnbm1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgYnlBc3RJZDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzdGF0ZS5ieUFzdElkKS5tYXAoKFthc3RJZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIFthc3RJZF06IHN0YXRlLmJ5QXN0SWRbYXN0SWRdLm1hcChcbiAgICAgICAgICAgICAgICBpZCA9PiBsZWFybkFkZHJlc3Moc3RhdGUuYnlJZFtpZF0sIGR1bW15QWRkcmVzcywgYWRkcmVzcykuaWRcbiAgICAgICAgICAgICAgICAvL3RoaXMgYWJvdmUgaW52b2x2ZXMgc29tZSByZWNvbXB1dGF0aW9uIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBERUZBVUxUX0FTU0lHTk1FTlRTO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWFybkFkZHJlc3MoYXNzaWdubWVudCwgZHVtbXlBZGRyZXNzLCBhZGRyZXNzKSB7XG4gIGlmIChhc3NpZ25tZW50LmR1bW15QWRkcmVzcyA9PT0gZHVtbXlBZGRyZXNzKSB7XG4gICAgLy93ZSBjYW4gYXNzdW1lIGhlcmUgdGhhdCB0aGUgb2JqZWN0IGJlaW5nXG4gICAgLy90cmFuc2Zvcm1lZCBoYXMgYSB2ZXJ5IHBhcnRpY3VsYXIgZm9ybVxuICAgIGxldCBuZXdJZE9iaiA9IHtcbiAgICAgIGFzdElkOiBhc3NpZ25tZW50LmFzdElkLFxuICAgICAgYWRkcmVzc1xuICAgIH07XG4gICAgbGV0IG5ld0lkID0gc3RhYmxlS2VjY2FrMjU2KG5ld0lkT2JqKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG5ld0lkLFxuICAgICAgcmVmOiBhc3NpZ25tZW50LnJlZixcbiAgICAgIGFzdElkOiBhc3NpZ25tZW50LmFzdElkLFxuICAgICAgYWRkcmVzc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2lnbm1lbnQ7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9NQVBQSU5HX0tFWVMgPSB7XG4gIGRlY29kaW5nU3RhcnRlZDogMCxcbiAgYnlJZDoge31cbn07XG5cbmZ1bmN0aW9uIG1hcHBpbmdLZXlzKHN0YXRlID0gREVGQVVMVF9NQVBQSU5HX0tFWVMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLk1BUF9LRVlfREVDT0RJTkc6XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJkZWNvZGluZyBzdGFydGVkOiAlZFwiLFxuICAgICAgICBzdGF0ZS5kZWNvZGluZ1N0YXJ0ZWQgKyAoYWN0aW9uLnN0YXJ0ZWQgPyAxIDogLTEpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RpbmdTdGFydGVkOiBzdGF0ZS5kZWNvZGluZ1N0YXJ0ZWQgKyAoYWN0aW9uLnN0YXJ0ZWQgPyAxIDogLTEpLFxuICAgICAgICBieUlkOiB7IC4uLnN0YXRlLmJ5SWQgfVxuICAgICAgfTtcbiAgICBjYXNlIGFjdGlvbnMuTUFQX0tFWTpcbiAgICAgIGxldCB7IGlkLCBrZXkgfSA9IGFjdGlvbjtcbiAgICAgIGRlYnVnKFwibWFwcGluZyBpZCBhbmQga2V5OiAlcywgJW9cIiwgaWQsIGtleSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlY29kaW5nU3RhcnRlZDogc3RhdGUuZGVjb2RpbmdTdGFydGVkLFxuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIC8vIGFkZCBuZXcga2V5IHRvIHNldCBvZiBrZXlzIGFscmVhZHkgZGVmaW5lZFxuICAgICAgICAgIFtpZF06IFtcbiAgICAgICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgICAvL3NldCBmb3IgdW5pcXVlbmVzc1xuICAgICAgICAgICAgICAuLi4oc3RhdGUuYnlJZFtpZF0gfHwgW10pLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIERFRkFVTFRfTUFQUElOR19LRVlTO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgYXNzaWdubWVudHMsXG4gIG1hcHBpbmdLZXlzXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVYVFMgPSB7XG4gIGJ5Q29udGV4dDoge30sXG4gIGJ5QmluYXJ5OiB7fVxufTtcblxuZnVuY3Rpb24gY29udGV4dHMoc3RhdGUgPSBERUZBVUxUX0NPTlRFWFRTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0NPTlRFWFQ6IHtcbiAgICAgIGNvbnN0IHsgY29udHJhY3ROYW1lLCByYXcsIGNvbXBpbGVyIH0gPSBhY3Rpb247XG4gICAgICBjb25zdCBjb250ZXh0ID0ga2VjY2FrMjU2KHJhdyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuXG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgLi4uKHN0YXRlLmJ5Q29udGV4dFtjb250ZXh0XSB8fCB7fSksXG5cbiAgICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjb21waWxlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFkZGluZyBiaW5hcnkgZm9yIGEgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfQklOQVJZOiB7XG4gICAgICBjb25zdCB7IGNvbnRleHQsIGJpbmFyeSB9ID0gYWN0aW9uO1xuXG4gICAgICBpZiAoc3RhdGUuYnlCaW5hcnlbYmluYXJ5XSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0W2NvbnRleHRdLFxuXG4gICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlCaW5hcnk6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUJpbmFyeSxcblxuICAgICAgICAgIFtiaW5hcnldOiB7IGNvbnRleHQ6IGNvbnRleHQgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0lOU1RBTkNFUyA9IHtcbiAgYnlBZGRyZXNzOiB7fSxcbiAgYnlDb250ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gaW5zdGFuY2VzKHN0YXRlID0gREVGQVVMVF9JTlNUQU5DRVMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgYWRkcmVzcyBmb3IgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfSU5TVEFOQ0U6XG4gICAgICBsZXQgeyBhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkgfSA9IGFjdGlvbjtcblxuICAgICAgLy8gZ2V0IGtub3duIGFkZHJlc3NlcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBzdGF0ZS5ieUNvbnRleHRbY29udGV4dF0gfHwgW107XG4gICAgICBsZXQgb3RoZXJBZGRyZXNzZXMgPSBvdGhlckluc3RhbmNlcy5tYXAoKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuXG4gICAgICAgICAgW2FkZHJlc3NdOiB7IGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlDb250ZXh0OiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0LFxuXG4gICAgICAgICAgLy8gcmVjb25zdHJ1Y3QgY29udGV4dCBpbnN0YW5jZXMgdG8gaW5jbHVkZSBuZXcgYWRkcmVzc1xuICAgICAgICAgIFtjb250ZXh0XTogQXJyYXkuZnJvbShuZXcgU2V0KG90aGVyQWRkcmVzc2VzKS5hZGQoYWRkcmVzcykpLm1hcChcbiAgICAgICAgICAgIGFkZHJlc3MgPT4gKHsgYWRkcmVzcyB9KVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgY29udGV4dHMsXG4gIGluc3RhbmNlc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsc3RhY2soc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQ0FMTDpcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY3Rpb24uYWRkcmVzcztcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoW3sgYWRkcmVzcyB9XSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOlxuICAgICAgY29uc3QgYmluYXJ5ID0gYWN0aW9uLmJpbmFyeTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoW3sgYmluYXJ5IH1dKTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVRVUk46XG4gICAgICAvL0hBQ0s6IHBvcCB0aGUgc3RhY2ssIFVOTEVTUyB0aGF0IHdvdWxkIGxlYXZlIGl0IGVtcHR5ICh0aGlzIHdpbGwgb25seVxuICAgICAgLy9oYXBwZW4gYXQgdGhlIGVuZCB3aGVuIHdlIHdhbnQgdG8ga2VlcCB0aGUgbGFzdCBvbmUgYXJvdW5kKVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDEgPyBzdGF0ZS5zbGljZSgwLCAtMSkgOiBzdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbc3RhdGVbMF1dOyAvL2xlYXZlIHRoZSBpbml0aWFsIGNhbGwgc3RpbGwgb24gdGhlIHN0YWNrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjYWxsc3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9yZWR1Y2Vycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIlxuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TT1VSQ0VTID0ge1xuICBieUlkOiB7fVxufTtcblxuZnVuY3Rpb24gc291cmNlcyhzdGF0ZSA9IERFRkFVTFRfU09VUkNFUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBzb3VyY2VcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX1NPVVJDRTpcbiAgICAgIGxldCB7IGFzdCwgc291cmNlLCBzb3VyY2VQYXRoLCBjb21waWxlciB9ID0gYWN0aW9uO1xuXG4gICAgICBsZXQgaWQgPSBPYmplY3Qua2V5cyhzdGF0ZS5ieUlkKS5sZW5ndGg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgY29tcGlsZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9TT1VSQ0VNQVBTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VNYXBzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VNQVBTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZU1hcFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFTUFQOlxuICAgICAgbGV0IHsgYmluYXJ5LCBzb3VyY2VNYXAgfSA9IGFjdGlvbjtcbiAgICAgIGxldCBjb250ZXh0ID0ga2VjY2FrMjU2KGJpbmFyeSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBDYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlcyxcbiAgc291cmNlTWFwc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbkRlcHRoKHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuSlVNUDpcbiAgICAgIGNvbnN0IGRlbHRhID0gc3BlbHVuayhhY3Rpb24uanVtcERpcmVjdGlvbik7XG4gICAgICByZXR1cm4gc3RhdGUgKyBkZWx0YTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiAwO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGVsdW5rKGp1bXApIHtcbiAgaWYgKGp1bXAgPT09IFwiaVwiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoanVtcCA9PT0gXCJvXCIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoanVtcCA9PT0gXCIyXCIpIHtcbiAgICByZXR1cm4gMjsgLy9IQUNLIFdPUktBUk9VTkRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgZnVuY3Rpb25EZXB0aFxufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChzdGF0ZSA9IDAsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlRPQ0s6XG4gICAgICByZXR1cm4gc3RhdGUgKyAxO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5pc2hlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FTkRfT0ZfVFJBQ0U6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBzKHN0YXRlID0gbnVsbCwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5TQVZFX1NURVBTKSB7XG4gICAgcmV0dXJuIGFjdGlvbi5zdGVwcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHN0ZXBzXG59KTtcblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZGV4LFxuICBmaW5pc2hlZFxufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2UvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpyZWR1Y2Vyc1wiKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZnVuY3Rpb24gYnJlYWtwb2ludHMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQUREX0JSRUFLUE9JTlQ6XG4gICAgICAvL2NoZWNrIGZvciBhbnkgZXhpc3RpbmcgaWRlbnRpY2FsIGJyZWFrcG9pbnRzIHRvIGF2b2lkIHJlZHVuZGFuY3lcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZmlsdGVyKFxuICAgICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICAgIGJyZWFrcG9pbnQuc291cmNlSWQgPT09IGFjdGlvbi5icmVha3BvaW50LnNvdXJjZUlkICYmXG4gICAgICAgICAgICBicmVha3BvaW50LmxpbmUgPT09IGFjdGlvbi5icmVha3BvaW50LmxpbmUgJiZcbiAgICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSA9PT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICApIHtcbiAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgdGhlcmUsIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9vdGhlcndpc2UgYWRkIGl0XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoW2FjdGlvbi5icmVha3BvaW50XSk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQlJFQUtQT0lOVDpcbiAgICAgIHJldHVybiBzdGF0ZS5maWx0ZXIoXG4gICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICBicmVha3BvaW50LnNvdXJjZUlkICE9PSBhY3Rpb24uYnJlYWtwb2ludC5zb3VyY2VJZCB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubGluZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubGluZSB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQUxMX0JSRUFLUE9JTlRTOlxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgYnJlYWtwb2ludHNcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IHNlc3Npb24gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc2Vzc2lvbi5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uaW5mby5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXMsIHNvbGlkaXR5LmluZm8uc291cmNlTWFwc10sXG5cbiAgICAgIChpbnN0YW5jZXMsIGNvbnRleHRzLCBzb3VyY2VzLCBzb3VyY2VNYXBzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAoW2FkZHJlc3MsIHtjb250ZXh0fV0pID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5zdGFuY2VzICVPXCIsIGluc3RhbmNlcyk7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbnRleHRzICVPXCIsIGNvbnRleHRzKTtcbiAgICAgICAgICAgIGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5IH0gPSBjb250ZXh0c1tjb250ZXh0XTtcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZU1hcCB9ID0gc291cmNlTWFwc1tjb250ZXh0XSB8fCB7fTtcblxuICAgICAgICAgICAgbGV0IHsgc291cmNlIH0gPSBzb3VyY2VNYXAgP1xuICAgICAgICAgICAgICAvLyBsb29rIGZvciBzb3VyY2UgSUQgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIGNvbG9ucyAoSEFDSylcbiAgICAgICAgICAgICAgc291cmNlc1tzb3VyY2VNYXAubWF0Y2goL15bXjpdKzpbXjpdKzooW146XSspOi8pWzFdXSA6XG4gICAgICAgICAgICAgIHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsIHNvdXJjZSwgYmluYXJ5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuXG4gIH0sXG5cblxuICAvKipcbiAgICogc2Vzc2lvbi50cmFuc2FjdGlvbiAobmFtZXNwYWNlKVxuICAgKi9cbiAgdHJhbnNhY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24gKHNlbGVjdG9yKVxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIF86IChzdGF0ZSkgPT4gc3RhdGUuc2Vzc2lvbi50cmFuc2FjdGlvbixcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24ucmVjZWlwdFxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHJlY2VpcHQgb2JqZWN0XG4gICAgICovXG4gICAgcmVjZWlwdDogKHN0YXRlKSA9PiBzdGF0ZS5zZXNzaW9uLnJlY2VpcHQsXG5cbiAgfVxuICBcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7Ozs7Ozs7OztBQ0lBO0FBWUE7QUFRQTtBQVFBO0FBU0E7QUFDQTtBQTFDQTtBQUNBO0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1Q0E7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQVRBO0FBQ0E7QUFXQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFEQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFLQTs7OztBQUlBO0FBQ0E7QUFLQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQVdBOzs7Ozs7O0FBT0E7QUFJQTtBQTFSQTtBQXhCQTtBQUNBO0FBdVRBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeFZBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBVkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQXRDQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBV0E7Ozs7OztBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckVBO0FBd0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7QUFkQTtBQUNBO0FBc0RBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7OztBQUlBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBR0E7QUFEQTtBQUNBO0FBSUE7OztBQUdBO0FBaERBO0FBQ0E7QUFrREE7OztBQUdBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQURBO0FBQ0E7QUFJQTtBQWJBO0FBekhBO0FBQ0E7QUF5SUE7Ozs7Ozs7Ozs7OztBQ2hUQTtBQVFBO0FBUUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQXJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkNBOzs7Ozs7Ozs7Ozs7QUNDQTtBQVNBO0FBT0E7QUFRQTtBQVNBO0FBUUE7QUExQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFSQTtBQUNBO0FBU0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBS0E7Ozs7O0FBS0E7QUFDQTtBQXJDQTtBQWRBO0FBQ0E7QUEyREE7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7OztBQU9BO0FBL0NBO0FBQ0E7QUFvREE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNBO0FBSUE7QUFJQTtBQXVTQTtBQUlBO0FBTUE7QUFrQkE7QUFDQTtBQTVWQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFkQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBNVBBO0FBOFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JXQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ0NBO0FBUUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQU1BO0FBUUE7QUFRQTtBQWxFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBYkE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFPQTtBQURBO0FBNUJBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFPQTtBQUNBO0FBRUE7QUFIQTtBQURBO0FBekJBO0FBSkE7QUFDQTtBQTJDQTs7Ozs7QUFLQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFMQTtBQUNBO0FBYUE7OztBQUdBO0FBMUdBO0FBQ0E7QUFtSEE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQXZEQTtBQUNBO0FBeURBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUpBO0FBQ0E7QUFNQTs7O0FBR0E7QUEzRUE7QUFDQTtBQWdGQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFHQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQXZCQTtBQUNBO0FBNEJBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFKQTtBQUNBO0FBTUE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBS0E7QUFDQTtBQUxBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQTVIQTtBQXZDQTtBQUNBO0FBb0xBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUpBO0FBemFBO0FBQ0E7QUFnYkE7Ozs7OztBQzFlQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1NBO0FBY0E7QUF5QkE7QUFDQTtBQWpEQTtBQUNBOzs7QUFFQTtBQUNBOzs7OztBQUhBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7OztBQ3BFQTs7Ozs7Ozs7Ozs7O0FDQ0E7QUFXQTtBQVFBO0FBUUE7QUFTQTtBQVFBO0FBS0E7QUFTQTtBQVFBO0FBbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NBO0FBbUNBO0FBU0E7QUFJQTtBQUNBO0FBN0VBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFWQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9EQTtBQW1CQTtBQWNBO0FBUUE7QUEyREE7QUFJQTtBQUNBO0FBN0hBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFiQTtBQUNBO0FBYUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9IQTtBQVVBO0FBU0E7QUFVQTtBQVFBO0FBUUE7QUFPQTtBQXJEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1Q0E7QUFJQTtBQXVEQTtBQUlBO0FBQ0E7QUEzRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBVEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdFQTtBQVVBO0FBU0E7QUFRQTtBQTVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFSQTtBQUNBO0FBUUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQW5CQTtBQW5CQTtBQUNBO0FBeUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUE1REE7QUFDQTtBQThEQTs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQWtCQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBekVBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBVkE7QUFDQTtBQVVBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkE7QUEyQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFyTUE7QUFBQTs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQXlDQTtBQUNBO0FBbERBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvRUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pKQTs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3Q0E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0ekNBO0FBQ0E7QUFsQkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQWZBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQTNEQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBUEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBOUJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFkQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0xBO0FBdUJBO0FBOEJBO0FBQ0E7QUE5R0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVRBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JIQTtBQVFBO0FBUUE7QUFRQTtBQVNBO0FBUUE7QUFTQTtBQW5EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBeERBO0FBQUE7Ozs7OztBQ05BOzs7Ozs7Ozs7Ozs7O0FDY0E7QUFhQTtBQVNBO0FBQ0E7QUFyQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBUEE7QUFDQTtBQU9BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSEE7QUFEQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBSEE7QUFMQTtBQVdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUZBO0FBREE7QUFNQTtBQW5CQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsREE7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVBBO0FBRkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQXpIQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBSEE7QUFlQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBQ0E7QUFTQTtBQUNBO0FBRUE7QUFIQTtBQVhBO0FBaUJBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQTFEQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUpBO0FBUEE7QUFDQTtBQWdCQTs7O0FBR0E7QUFDQTtBQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUN4SkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQytFQTtBQUNBO0FBaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBREE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBREE7QUFDQTtBQVVBOzs7QUFHQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7QUM5R0E7QUFhQTtBQWFBO0FBQ0E7QUEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQU5BO0FBQ0E7QUFNQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUEzQkE7QUFDQTtBQWlDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQWJBO0FBQ0E7QUExQ0E7QUFDQTtBQTBEQTs7OztBIiwic291cmNlUm9vdCI6IiJ9